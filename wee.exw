-- Wee Euphoria Editor
-- 
-- Copyright (c) 1998-2015  Pete Eberlein
-- 
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
-- 
-- The above copyright notice and this permission notice shall be included in
-- all copies or substantial portions of the Software.
-- 
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-- THE SOFTWARE.

global constant
  window_title = "Wee Euphoria Editor",
  author = "Pete Eberlein <pete.eberlein@gmail.com>",
  version = "0.28"

-- revision notes:
--  added: syntax coloring!
--  bug fixed: save mode changed to "wb" (Thanks Lucius)
--  added: replace all
--  added: goto error
--  fixed: hotkeys
--  added: cursor position
--  added: recent files list
--  added: saving window pos+size and recent files to "wee_conf.txt"
--  added: subroutines list dialog (F2)
--  added: choose font dialog (we suggest "Consolas" 11pt)
--  added: tabs (can be selected using Alt+1..9)
--  added: watch tabs for changes to files and ex.err
--  added: goto declaration (Ctrl+F2) and view completions (Ctrl+Space)
--  added: Scintilla edit control (using Lua lexer :/)
--  added: view completions will search std includes
--  added: Search->Find will remember last phrase
--  added: auto expansions for "if" "while" "for" and subroutines (thanks dcuny)
--  added: auto indent newlines
--  added: type ':' to autocomplete a namespace
--  added: auto-complete with include puts it near top of file
--  added: auto insert closing characters for ( { [ " '
--  added: typing '(' after a subroutine will popup hints
--  added: hardcoded list of builtins and arguments in get_subroutine_arguents()
--  updated: ex.err dialog with buttons: <cancel> <open ex.err> <goto error>
--    and listbox with call stack or multiple undeclared references
--  updated: indent/unindent selection with tab/shift-tab
--  Linux/Mac (using EuGTK)
--  store syntax highlighting colors in wee.conf
--  context-sensitive help (hit F1 on a word)
--  run with arguments (Shift+F5)
--  move options to separate menu
--  option to sort subroutines in View Subroutines dialog
--  added Bind, Shroud and Translate to Run menu
--  dialog to change syntax highlighting colors
--  popup menu on tab control
--  drag'n'drop files
--  fill in Find dialog with current selection
--  allow search backward in Find and Replace dialogs
--  quick search Find Next (Ctrl+G) Find Previous (Shift+Ctrl+G)
--  comment/uncomment selected lines (Ctrl+M)
--  go back (Esc) after doing View Declaration or Goto Error
--    if there is a selection, it will be deselected first
--  line wrap option
--  autocompletion list shows icons for each type of declaration
--  Run menu choose which intepreter to use
--  Option to reopen tabs next time

--  bugs fixed:
--    ViewDeclaration wrong cursor pos
--    audible ding when pressing Alt+1..9
--    ViewCompletions on whitespace crash
--    parser updates cache for modified include files
--    files are now opened in binary mode since scintilla can handle any line endings
--    fixed tab names not updating when save-as
--    fixed "too many open files" error, wasn't closing files in view_error function
--    fixed parsing ifdefs
--    fixed crash after changing font (thanks euphoric)
--    reloading a file that is modified externally loads into wrong tab (thanks dcuny)
--    autocomplete avoids activating inside comments and strings
--    fix weirdness with deletion autoinserted closing characters
--    fix calltip popup displaying incorrect highlight after first time
--    fix EOL mode on Linux/OSX
--    completions are now sorted
--    switch/case syntax highlight and autocomplete were missing
--    shift-ctrl-Z does redo
--    better at locating scintilla library when bound/compiled
--    run/bind/shroud/translate didn't like spaces in the path
--    preserve selection during comment/uncomment lines

-- todo:
--  save tabs in conf file? option to restore last tabs?
--  64-bit safe on Windows (Linux/OSX ok)
--  bug with reloading files, first few characters get garbled
--  expanding "for" should then tab between "=", "to", and "do"
--    as it is now, its really annoying (better with overtyping)
--  fix brace highlighting in comments and strings
--  configurable indent size
--  namespaces might still need to be fixed (include as)
--  put arguments after each subroutine completion (maybe)
--  investigate Mike Duffy's scintilla Euphoria Lexer
--    multicolored brackets and parens
--    multiline comments and strings
--  code-aware identifier rename
--    add function to parser to get all instances of identifier in scope
--    use multi-select to replace all instances in one shot
--    limited to a single file (too difficult otherwise)
--  macro recording (SCI_STARTRECORD/SCI_STOPRECORD/SCN_MACRORECORD)
--  disable menu items when the action has no effect
--    disable cut/copy when no selection, or paste with empty clipboard
--    disable undo/redo when nothing to do
--    disable go back when nowhere to go back to

without warning

include parser.e
include scintilla.e
include get.e
include std/filesys.e
include std/sequence.e
include misc.e


-- The ui includes are circular includes: 
--      wee.exw -> ui_win.e -> wee.exw
-- The ui include is responsible for calling wee_init() and startup.
ifdef WINDOWS then
include ui_win.e
elsedef
include ui_gtk.e
end ifdef

-- all variables must be initialized in wee_init() due to circular include
constant 
    indent_size = 4 -- TODO: make this user configurable
global constant max_recent_files = 5
global atom x_pos, y_pos, x_size, y_size
global sequence font_name
global integer font_height, line_numbers, sorted_subs, line_wrap, reopen_tabs
global sequence file_name, run_file_name, ex_err_name, recent_files
global integer keyword_color, builtin_color, string_color,
    comment_color, number_color, normal_color, background_color,
    linenumber_color, bracelight_color
global sequence find_phrase, replace_phrase, interpreter


-- local variables
sequence
	tab_hedits, tab_file_names, tab_timestamps, 
	recent_pos, indent_str, tab_arguments, tab_pos_stack
integer current_tab, modified, initial_tab
atom hedit
atom ex_err_timestamp
integer expand_line, last_deleted_char
sequence insert_chars
sequence calltip_args -- {{start,end},...}
integer calltip_pos
sequence calltip_stack -- {calltip_pos, calltip_args...}
sequence calltip_text -- "routine_name(type1 arg1, ...)"
sequence wee_conf_filename
sequence search_idx, search_dat
sequence tabs_to_open

-- shorthand helper function
function ssm(integer m, object w=0, object l=0)
    return scintilla_send_message(hedit, m, w, l)
end function


function crash_cleanup(object x)
  ui_message_box_error(window_title,
    "Houston, Wee have a problem.\n\n" &
    "The editor crashed and is closing now.\n")
  save_modified_tabs()
  if length(wee_conf_filename) then
    save_wee_conf(wee_conf_filename)
  end if
  return 0
end function


constant
a_xpm = `/* XPM */
"16 16 28 1",
" 	c None",
".	c #3300CC",
"+	c #FFFFFF",
"@	c #FBFBFD",
"#	c #E6E1F8",
"$	c #AD99EA",
"%	c #4011CE",
"&	c #7553DB",
"*	c #3807CC",
"=	c #8061DE",
"-	c #B3A1EB",
";	c #3503CC",
">	c #EBE7F9",
",	c #4A1DD1",
"'	c #B9A8ED",
")	c #FDFDFD",
"!	c #CBBEF1",
"~	c #947AE3",
"{	c #3A0ACD",
"]	c #F6F4FC",
"^	c #3A09CD",
"/	c #DAD2F5",
"(	c #7958DD",
"_	c #3908CC",
":	c #8E72E2",
"<	c #5F38D6",
"[	c #DAD1F5",
"}	c #8162DF",
"     ......     ",
"   ..........   ",
"  ............  ",
" .............. ",
" ....++@#$%.... ",
".....+&*=+-.....",
"........;+>.....",
"....,'>)+++.....",
"....!+~{.++.....",
"....]+^.;++.....",
"..../+(_:++.....",
" ...<[]/}+++... ",
" .............. ",
"  ............  ",
"   ..........   ",
"     ......     "};`,
c_xpm = `/* XPM */
static char * c_xpm[] = {
"16 16 33 1",
" 	c None",
".	c #3399CC",
"+	c #6EB6DA",
"@	c #D1E7F3",
"#	c #F7FAFC",
"$	c #F2F8FB",
"%	c #C3E0EF",
"&	c #6AB4D9",
"*	c #FDFDFD",
"=	c #BFDFEE",
"-	c #46A2D0",
";	c #42A0CF",
">	c #BBDDED",
",	c #FFFFFF",
"'	c #D0E7F2",
")	c #55A9D3",
"!	c #4AA4D1",
"~	c #F6FAFC",
"{	c #3A9CCD",
"]	c #D2E8F3",
"^	c #56AAD4",
"/	c #4BA4D1",
"(	c #E1EFF6",
"_	c #72B8DB",
":	c #C1DFEF",
"<	c #43A0CF",
"[	c #93C8E3",
"}	c #73B8DB",
"|	c #D4E9F3",
"1	c #F8FBFC",
"2	c #EBF4F9",
"3	c #A4D1E8",
"4	c #3599CC",
"     ......     ",
"   ..........   ",
"  ............  ",
" .............. ",
" ....+@#$%&.... ",
"....+*=-;>,.....",
"....',)..!,.....",
"....~,{.........",
"....~,{.........",
"....],^../(.....",
"...._,:-<=[.....",
" ....}|1234.... ",
" .............. ",
"  ............  ",
"   ..........   ",
"     ......     "};`,
e_xpm = `/* XPM */
static char * e_xpm[] = {
"16 16 37 1",
" 	c None",
".	c #CC0099",
"+	c #D844B3",
"@	c #F1C0E5",
"#	c #FBF3F9",
"$	c #FCF6FA",
"%	c #F3C8E8",
"&	c #DA4EB7",
"*	c #D945B4",
"=	c #FDFCFD",
"-	c #E684CD",
";	c #CE0E9E",
">	c #CE0F9E",
",	c #E688CF",
"'	c #FDFDFD",
")	c #D73BB0",
"!	c #F2C3E6",
"~	c #FFFFFF",
"{	c #CD0C9D",
"]	c #F0B8E2",
"^	c #FCF5FA",
"/	c #F9E9F5",
"(	c #CD0B9C",
"_	c #F2C5E7",
":	c #D637AE",
"<	c #D42DAA",
"[	c #F5D2EC",
"}	c #DA4AB6",
"|	c #F3C7E8",
"1	c #D32BA9",
"2	c #CC089B",
"3	c #D534AD",
"4	c #F4D0EB",
"5	c #DE5EBE",
"6	c #D948B5",
"7	c #F4CFEB",
"8	c #DE60BF",
"     ......     ",
"   ..........   ",
"  ............  ",
" .............. ",
" ....+@#$%&.... ",
"....*=-;>,')....",
"....!~{..;~]....",
"....^~~~~~~/....",
"....^~(.........",
"...._~:...<[....",
"....}'|12345....",
" ....6@##78.... ",
" .............. ",
"  ............  ",
"   ..........   ",
"     ......     "};`,
f_xpm = `/* XPM */
static char * f_xpm[] = {
"16 16 11 1",
" 	c None",
".	c #0044FF",
"+	c #2A62FE",
"@	c #BDCEFE",
"#	c #F2F5FE",
"$	c #FFFFFF",
"%	c #CBD8FE",
"&	c #3A6EFE",
"*	c #366BFE",
"=	c #FAFBFE",
"-	c #0044FE",
"     ......     ",
"   ..........   ",
"  ............  ",
" .....+@#$$.... ",
" .....%$&*$.... ",
"......=$-.......",
".....$$$$$......",
"......$$........",
"......$$........",
"......$$........",
"......$$........",
" .....$$....... ",
" .....$$....... ",
"  ...$$$$.....  ",
"   ..........   ",
"     ......     "};`,
i_xpm = `/* XPM */
static char * i_xpm[] = {
"16 16 6 1",
" 	c None",
".	c #CC0033",
"+	c #F2C4CF",
"@	c #F2C3CF",
"#	c #F3C6D1",
"$	c #FFFFFF",
"     ......     ",
"   ..........   ",
"  .....+@.....  ",
" ......#+...... ",
" .............. ",
"......$$$.......",
".......$$.......",
".......$$.......",
".......$$.......",
".......$$.......",
".......$$.......",
" ......$$...... ",
" .....$$$$..... ",
"  ............  ",
"   ..........   ",
"     ......     "};`,
o_xpm = `/* XPM */
static char * o_xpm[] = {
"16 16 20 1",
" 	c None",
".	c #00CC99",
"+	c #45D9B4",
"@	c #C2F2E6",
"#	c #F5FCFA",
"$	c #FCFDFD",
"%	c #A8EDDB",
"&	c #16CFA1",
"*	c #14CFA0",
"=	c #A3ECD9",
"-	c #C3F2E6",
";	c #FFFFFF",
">	c #23D2A6",
",	c #22D2A6",
"'	c #04CC9A",
")	c #03CC99",
"!	c #A6ECDB",
"~	c #15CFA0",
"{	c #A5ECDA",
"]	c #44D8B3",
"     ......     ",
"   ..........   ",
"  ............  ",
" .............. ",
" ....+@##@+.... ",
"....+$%&*=$+....",
"....-;>..,;@....",
"....#;'..);#....",
"....#;)..';#....",
"....@;>..>;@....",
"....+$!~*{$]....",
" ....+-##-+.... ",
" .............. ",
"  ............  ",
"   ..........   ",
"     ......     "};`,
p_xpm = `/* XPM */
static char * p_xpm[] = {
"16 16 25 1",
" 	c None",
".	c #FF6600",
"+	c #FFFFFF",
"@	c #FEA66C",
"#	c #FEEDE3",
"$	c #FEFAF8",
"%	c #FEE3D1",
"&	c #FE9854",
"*	c #FECAA8",
"=	c #FE7216",
"-	c #FE7215",
";	c #FE8D42",
">	c #FE7A22",
",	c #FE7B24",
"'	c #FED8BF",
")	c #FE6703",
"!	c #FE6804",
"~	c #FEF3EC",
"{	c #FEC9A6",
"]	c #FECAA7",
"^	c #FE8E43",
"/	c #FEEEE4",
"(	c #FEFBF9",
"_	c #FEE3D2",
":	c #FE9A57",
"     ......     ",
"   ..........   ",
"  ............  ",
" ...+++@#$%&... ",
" ....++*=-*+;.. ",
".....++>..,+'...",
".....++)..!+~...",
".....++)..!+~...",
".....++>..,+'...",
".....++{--]+^...",
".....++@/(_:....",
" ....++........ ",
" ....++........ ",
"  ..++++......  ",
"   ..........   ",
"     ......     "};`,
s_xpm = `/* XPM */
static char * s_xpm[] = {
"16 16 34 1",
" 	c None",
".	c #33CC00",
"+	c #4BD11F",
"@	c #B6ECA4",
"#	c #E8F8E3",
"$	c #FAFDF9",
"%	c #FFFFFF",
"&	c #D2F3C7",
"*	c #7BDD5B",
"=	c #38CC07",
"-	c #4AD11D",
";	c #C0EEB1",
">	c #F7FCF6",
",	c #6AD945",
"'	c #35CC03",
")	c #CAF1BD",
"!	c #F9FCF8",
"~	c #E0F6D9",
"{	c #A4E78D",
"]	c #41CE12",
"^	c #44CF16",
"/	c #EBF9E7",
"(	c #CBF1BE",
"_	c #4ED222",
":	c #3DCD0D",
"<	c #77DC55",
"[	c #F6FCF4",
"}	c #C8F0BB",
"|	c #37CC06",
"1	c #78DC57",
"2	c #D3F3C9",
"3	c #FCFDFC",
"4	c #ECF9E8",
"5	c #BCEDAC",
"     ......     ",
"   ..........   ",
"  ............  ",
" .............. ",
" ....+@#$%%%... ",
".....&%*=-;%....",
".....>%,'.-%....",
".....)%%!~{]....",
".....^@/%%%(....",
".....%_.:<%[....",
".....%}_|1%2....",
" ....%%%345+... ",
" .............. ",
"  ............  ",
"   ..........   ",
"     ......     "};`,
t_xpm = `/* XPM */
static char * t_xpm[] = {
"16 16 11 1",
" 	c None",
".	c #CC9900",
"+	c #FFFFFF",
"@	c #F9F4E6",
"#	c #D2A622",
"$	c #D5AD34",
"%	c #DEBF60",
"&	c #F8F2E1",
"*	c #FDFCF9",
"=	c #F8F3E3",
"-	c #DEBE5E",
"     ......     ",
"   ..........   ",
"  ............  ",
" .....++....... ",
" .....++....... ",
".....+++++......",
"......++........",
"......++........",
"......++........",
"......++........",
"......++........",
" .....@+#$@.... ",
" .....%&*=-.... ",
"  ............  ",
"   ..........   ",
"     ......     "};`


constant             -- colors of various syntax classes
    Black = #000000,
    Gray = #AAAAAA,
    DGray = #808080,
    Green = #00AA00,
    Yellow = #88FFFF,
    Magenta = #AA00AA,
    Cyan = #AAAA00,
    Red = #0000AA,
    Blue = #AA0000,
    LightBlue = #FFFFDD,
    White = #FFFFFF

global procedure wee_init()

  wee_conf_filename = ""

  crash_routine(routine_id("crash_cleanup"))

  recent_files = {}
  recent_pos = {}

  font_name = ""
  font_height = 10
  line_numbers = 0
  sorted_subs = 0
  line_wrap = 0

  file_name = ""
  hedit = 0
  
  run_file_name = ""
  ex_err_name = "ex.err"
  ex_err_timestamp = get_timestamp(ex_err_name)
ifdef WINDOWS then
  interpreter = "euiw"
elsedef
  interpreter = "eui"
end ifdef

  tab_hedits = {}
  tab_file_names = {}
  tab_timestamps = {}
  tab_arguments = {}
  tab_pos_stack = {}

  modified = 0
  expand_line = -1
  insert_chars = ""
  last_deleted_char = 0

  indent_str = repeat(' ', indent_size)
  calltip_args = {}
  calltip_pos = -1
  calltip_stack = {}
  calltip_text = ""
  
  current_tab = 0

  normal_color = Black
  background_color = White
  comment_color = DGray
  number_color = Black
  keyword_color = Green
  builtin_color = Magenta
  string_color = Blue
  bracelight_color = LightBlue
  linenumber_color = DGray

  search_idx = {}
  search_dat = {}

  find_phrase = ""
  replace_phrase = ""
  
  reopen_tabs = 0
  tabs_to_open = {}
  initial_tab = 1
  
end procedure



global procedure load_wee_conf(sequence wee_conf_file)
    integer f, eq
    object l
    sequence key, val
    f = open(wee_conf_file, "r")
    if f = -1 then return end if
    wee_conf_filename = wee_conf_file
    l = gets(f)
    while sequence(l) do
        eq = find('=', l)
        if eq then
            key = l[1..eq-1]
            val = l[eq+1..length(l)-1]
            l = value(val)
            if equal(key, "x_pos") and integer(l[2]) then
                x_pos = l[2]
            elsif equal(key, "y_pos") and integer(l[2]) then
                y_pos = l[2]
            elsif equal(key, "x_size") and integer(l[2]) then
                x_size = l[2]
            elsif equal(key, "y_size") and integer(l[2]) then
                y_size = l[2]
            elsif equal(key, "recent_file") then
                recent_files &= {val}
            elsif equal(key, "recent_pos") and integer(l[2]) then
                recent_pos &= l[2]
            elsif equal(key, "font_name") then
                font_name = val
            elsif equal(key, "font_height") and integer(l[2]) then
                font_height = l[2]
                if font_height < 0 then 
                    font_height = -floor((font_height*96+36)/72)
                end if
            elsif equal(key, "line_numbers") and integer(l[2]) then
                line_numbers = l[2]
            elsif equal(key, "normal_color") and integer(l[2]) then
                normal_color = l[2]
            elsif equal(key, "background_color") and integer(l[2]) then
                background_color = l[2]
            elsif equal(key, "comment_color") and integer(l[2]) then
                comment_color = l[2]
            elsif equal(key, "keyword_color") and integer(l[2]) then
                keyword_color = l[2]
            elsif equal(key, "builtin_color") and integer(l[2]) then
                builtin_color = l[2]
            elsif equal(key, "number_color") and integer(l[2]) then
                number_color = l[2]
            elsif equal(key, "linenumber_color") and integer(l[2]) then
                linenumber_color = l[2]
            elsif equal(key, "bracelight_color") and integer(l[2]) then
                bracelight_color = l[2]
            elsif equal(key, "sorted_subs") and integer(l[2]) then
                sorted_subs = l[2]
            elsif equal(key, "line_wrap") and integer(l[2]) then
                line_wrap = l[2]
            elsif equal(key, "interpreter") then
                interpreter = val
            elsif equal(key, "reopen_tabs") and integer(l[2]) then
                reopen_tabs = l[2]
            elsif equal(key, "open_tab") then
		if length(l[2]) = 3 and sequence(l[2][1]) and integer(l[2][2]) and integer(l[2][3]) then
		    tabs_to_open = append(tabs_to_open, l[2])
		else
		    tabs_to_open = append(tabs_to_open, val)
		end if
            elsif equal(key, "initial_tab") and integer(l[2]) then
                initial_tab = l[2]
            end if
        end if
        l = gets(f)
    end while
    close(f)
end procedure

global procedure save_wee_conf(sequence wee_conf_file)
    integer f
    f = open(wee_conf_file, "w")
    printf(f, "x_pos=%d\ny_pos=%d\nx_size=%d\ny_size=%d\nline_numbers=%d\n", 
	{x_pos, y_pos, x_size, y_size, line_numbers})
    for i = 1 to length(recent_files) do
        puts(f, "recent_file="&recent_files[i]&"\n")
        printf(f, "recent_pos=%d\n", {recent_pos[i]})
    end for
    if length(font_name) and font_height != 0 then
      printf(f, "font_name=%s\nfont_height=%d\n", {font_name, font_height})
    end if
    printf(f, "normal_color=#%06x\n", {normal_color})
    printf(f, "background_color=#%06x\n", {background_color})
    printf(f, "keyword_color=#%06x\n", {keyword_color})
    printf(f, "builtin_color=#%06x\n", {builtin_color})
    printf(f, "comment_color=#%06x\n", {comment_color})
    printf(f, "number_color=#%06x\n", {number_color})
    printf(f, "string_color=#%06x\n", {string_color})
    printf(f, "linenumber_color=#%06x\n", {linenumber_color})
    printf(f, "bracelight_color=#%06x\n", {bracelight_color})
    printf(f, "sorted_subs=%d\n", {sorted_subs})
    printf(f, "line_wrap=%d\n", {line_wrap})
    printf(f, "interpreter=%s\n", {interpreter})
    printf(f, "reopen_tabs=%d\n", {reopen_tabs})
    printf(f, "initial_tab=%d\n", {current_tab})
    if reopen_tabs then
        for i = 1 to length(tab_file_names) do
	    if length(tab_file_names[i]) then
		hedit = tab_hedits[i]
	        printf(f, "open_tab={\"%s\",%d,%d}\n", {
		    tab_file_names[i],
		    ssm(SCI_GETCURRENTPOS),
		    ssm(SCI_GETFIRSTVISIBLELINE)})
	    end if
        end for
    end if
    close(f)
end procedure



function sreplace(sequence text, sequence what, sequence replacement)
    integer i
    i = match(what, text)
    if i then
        return text[1..i-1] & replacement & text[i+length(what)..$]
    end if
    return text
end function

-- init edit, (or reinit all existing edits when hedit = 0)
global procedure init_edit(atom edit)
    sequence font
    
    hedit = edit
    
    --? {hedit, ssm(SCI_GETIDENTIFIER, 0, 0)}
    font = font_name
    ifdef not WINDOWS then
	font = sreplace(font, "Medium", "")
	font = sreplace(font, "Thin", "")
	font = sreplace(font, "Bold", "")
	font = sreplace(font, "Italic", "")
	font = sreplace(font, "Condensed", "")
	font = rtrim(font)
	--puts(1, font&".\n")
    end ifdef

    ssm(SCI_STYLESETFONT, STYLE_DEFAULT, font)
    ifdef not WINDOWS then
      ssm(SCI_STYLESETBOLD, STYLE_DEFAULT, match(" Bold", font_name))
      ssm(SCI_STYLESETITALIC, STYLE_DEFAULT, match(" Italic", font_name))
    end ifdef
    ssm(SCI_STYLESETSIZE, STYLE_DEFAULT, font_height)
    ssm(SCI_STYLESETFORE, STYLE_DEFAULT, normal_color)
    ssm(SCI_STYLESETBACK, STYLE_DEFAULT, background_color)
    ssm(SCI_STYLECLEARALL)

    ssm(SCI_SETLEXER, SCLEX_LUA)
    ssm(SCI_SETKEYWORDS, 0, 
     "procedure function type end and or xor not if then elsif else for to by do while "&
     "global constant include with without return exit " &
     -- OE4
     "public export enum as namespace ifdef elsifdef elsedef "&
     "label entry break continue loop until routine switch case fallthru"
     )
    ssm(SCI_SETKEYWORDS, 1, get_builtins())

    ssm(SCI_STYLESETFORE, SCE_LUA_COMMENT, comment_color)
    ssm(SCI_STYLESETFORE, SCE_LUA_COMMENTLINE, comment_color)
    ssm(SCI_STYLESETFORE, SCE_LUA_NUMBER, number_color)
    ssm(SCI_STYLESETFORE, SCE_LUA_WORD, keyword_color)
    ssm(SCI_STYLESETFORE, SCE_LUA_WORD2, builtin_color)
    ssm(SCI_STYLESETFORE, SCE_LUA_STRING, string_color)

    ssm(SCI_STYLESETBACK, STYLE_BRACELIGHT, bracelight_color)
    ssm(SCI_STYLESETBOLD, STYLE_BRACELIGHT, 1)
    
    ssm(SCI_STYLESETFORE, STYLE_LINENUMBER, linenumber_color)
    ssm(SCI_SETMARGINWIDTHN, 0, 48*line_numbers) -- line numbers margin visible
    ssm(SCI_SETMARGINWIDTHN, 1, 0) -- non-folding symbols margin hidden
    
    ssm(SCI_SETINDENT, indent_size)

    ssm(SCI_AUTOCSETSEPARATOR, '\n')
    ssm(SCI_AUTOCSTOPS, 0, " ")
    ssm(SCI_AUTOCSETFILLUPS, 0, "")
    --ssm(SCI_AUTOCSETORDER, SC_ORDER_CUSTOM) -- declaration order
    ssm(SCI_AUTOCSETORDER, SC_ORDER_PERFORMSORT) -- scintilla should sort
    ssm(SCI_AUTOCSETCANCELATSTART)

    -- call tips display above text
    --ssm(SCI_CALLTIPSETPOSITION, 1)

    -- get modification events for deletetext
    ssm(SCI_SETMODEVENTMASK, SC_MOD_BEFOREDELETE)
    
    ssm(SCI_SETWRAPMODE, line_wrap)

    ifdef WINDOWS then
	ssm(SCI_SETEOLMODE, SC_EOL_CRLF)
    elsedef
	ssm(SCI_SETEOLMODE, SC_EOL_LF)
    end ifdef
    
    ssm(SCI_REGISTERIMAGE, DECL_ATOM, a_xpm)
    ssm(SCI_REGISTERIMAGE, DECL_CONSTANT, c_xpm)
    ssm(SCI_REGISTERIMAGE, DECL_ENUM, e_xpm)
    ssm(SCI_REGISTERIMAGE, DECL_FUNCTION, f_xpm)
    ssm(SCI_REGISTERIMAGE, DECL_INTEGER, i_xpm)
    ssm(SCI_REGISTERIMAGE, DECL_OBJECT, o_xpm)
    ssm(SCI_REGISTERIMAGE, DECL_PROCEDURE, p_xpm)
    ssm(SCI_REGISTERIMAGE, DECL_SEQUENCE, s_xpm)
    ssm(SCI_REGISTERIMAGE, DECL_TYPE, t_xpm)
end procedure

global procedure reinit_all_edits()
    atom saved_hedit
    saved_hedit = hedit
    for i = 1 to length(tab_hedits) do
        init_edit(tab_hedits[i])
    end for
    hedit = saved_hedit
end procedure

-- pos is integer position in current tab, or {"filename", pos}
-- note: first character in document is at pos=1
global procedure goto_pos(object pos, integer len=0)
    sequence prev = {ssm(SCI_GETCURRENTPOS),
	             ssm(SCI_GETFIRSTVISIBLELINE)}

    if sequence(pos) then
	sequence prev_file = file_name
	if open_file(pos[1], 0) = 0 then
	    return -- file not found
	end if
	pos = pos[2]
	if not equal(file_name, prev_file) then
	    -- open_file probably changed the current_tab
	    prev &= {prev_file}
	end if
    end if
    tab_pos_stack[current_tab] &= {prev}
    pos -= 1
    ssm(SCI_SETANCHOR, pos)
    ssm(SCI_SETCURRENTPOS, pos + len)
    set_top_line(-1)
end procedure

-- restore the previous cursor and scroll position,
-- or clear the selection if there is one
global procedure go_back()
    object pos = ssm(SCI_GETCURRENTPOS)
    
    -- clear any selection, and return
    if pos != ssm(SCI_GETANCHOR) then
        ssm(SCI_SETEMPTYSELECTION, pos)
        return
    end if

    if length(tab_pos_stack[current_tab]) = 0 then
        return -- empty stack
    end if

    -- get the last {pos,top_line,[filename]} on stack, and remove it
    pos = tab_pos_stack[current_tab][$]
    tab_pos_stack[current_tab] = tab_pos_stack[current_tab][1..$-1]

    if sequence(pos) and length(pos) >= 3 then
	if length(pos[3]) = 0 then
	    -- fixme: pick first untitled tab
	    integer tab = find("", tab_file_names)
	    if tab = 0 then
	        return
	    end if
	    select_tab(tab)
	elsif open_file(pos[3], 0) = 0 then
            return -- file not found or user cancelled
        end if
    end if
    ssm(SCI_SETEMPTYSELECTION, pos[1])
    set_top_line(pos[2])
end procedure

global function get_pos()
    return ssm(SCI_GETCURRENTPOS)
end function

global function get_selection()
    integer len
    atom buf
    sequence text
    
    len = ssm(SCI_GETSELTEXT)
    if len <= 1 then
        return ""
    end if
    buf = allocate(len)
    ssm(SCI_GETSELTEXT, 0, buf)
    text = peek({buf, len - 1})
    free(buf)
    return text
end function

global procedure set_top_line(integer line)
    integer fv, los
    if line = -1 then
        line = ssm(SCI_LINEFROMPOSITION, get_pos())
    end if
    fv = ssm(SCI_GETFIRSTVISIBLELINE)
    los = ssm(SCI_LINESONSCREEN)
    if line >= fv and line < fv + los-1 then
	return -- don't need to scroll
    end if
    line = ssm(SCI_SETFIRSTVISIBLELINE, line)
end procedure

global function get_modified()
    return ssm(SCI_GETMODIFY)
end function

global function get_line_length(integer line)
    if line = -1 then
        line = ssm(SCI_LINEFROMPOSITION, get_pos())
    end if
    return ssm(SCI_LINELENGTH, line)
end function

global function get_line_end_position(integer line)
    if line = -1 then
        line = ssm(SCI_LINEFROMPOSITION, get_pos())
    end if
    return ssm(SCI_GETLINEENDPOSITION, line)
end function

global function get_line_start_position(integer line)
    if line = -1 then
        line = ssm(SCI_LINEFROMPOSITION, get_pos())
    end if
    return ssm(SCI_POSITIONFROMLINE, line)
end function


global function get_line(integer line)
    atom junk, len, buf
    sequence text

    if line = -1 then
        line = ssm(SCI_LINEFROMPOSITION, get_pos())
    end if
    len = get_line_length(line)
    buf = allocate(len+1)
    ssm(SCI_GETLINE, line, buf)
    text = peek({buf, len})
    free(buf)
    return text
end function

global function get_edit_text()
    atom junk, text_buffer, text_len
    sequence text

    text_len = ssm(SCI_GETTEXTLENGTH)+1
    text_buffer = allocate(text_len)
    ssm(SCI_GETTEXT, text_len, text_buffer)
    text = peek({text_buffer, text_len-1})
    free(text_buffer)
    return text
end function

global procedure update_status()
    atom pos, line, col
    pos = get_pos()
    line = 1+ssm(SCI_LINEFROMPOSITION, pos)
    col = 1+ssm(SCI_GETCOLUMN, pos)
    ui_update_status(sprintf("%d:%d ", {line, col}))
    if line-1 != expand_line then
        expand_line = -1
    end if
end procedure


--------------------------------------
-- search and replace
--------------------------------------

-- search for the phrase (sequence or pointer) and set the editor target
-- returns 1 if found, otherwise 0
global function search_find(sequence phrase, integer backward = 0)
    if backward then
	ssm(SCI_SETTARGETSTART, ssm(SCI_GETSELECTIONSTART))
	ssm(SCI_SETTARGETEND, 0)
    else
	ssm(SCI_SETTARGETSTART, ssm(SCI_GETSELECTIONEND))
	ssm(SCI_SETTARGETEND, ssm(SCI_GETTEXTLENGTH))
    end if
    
    if ssm(SCI_SEARCHINTARGET, length(phrase), phrase) < 0 then
	-- wrap around and search again
	if backward then
	    ssm(SCI_SETTARGETSTART, ssm(SCI_GETTEXTLENGTH))
	else
	    ssm(SCI_SETTARGETSTART, 0)
	end if
	if ssm(SCI_SEARCHINTARGET, length(phrase), phrase) < 0 then
	    -- clear the target so search_replace won't do bad things
	    ssm(SCI_SETTARGETSTART, 0)
	    ssm(SCI_SETTARGETEND, 0)
	    return 0
	end if
    end if
    -- set selection from target
    ssm(SCI_SETSEL, ssm(SCI_GETTARGETSTART), ssm(SCI_GETTARGETEND))
    
    return 1
end function

-- replace the editor target with the phrase (sequence or pointer)
-- returns 1 if replace made, otherwise 0
global function search_replace(sequence phrase)
    integer pos = ssm(SCI_GETTARGETSTART)
    if pos < ssm(SCI_GETTARGETEND) then
	-- replace or replace_all
	ssm(SCI_REPLACETARGET, length(phrase), phrase)
	-- set the current pos to the end, so that the next
	-- find doesn't search within the replacement phrase
	ssm(SCI_SETANCHOR, pos)
	ssm(SCI_SETCURRENTPOS, pos + length(phrase))
	return 1
    end if
    return 0
end function

-- replace all in document, saving the cursor position
-- returns count of replacements made
global function search_replace_all(sequence what, sequence phrase)
    integer
	pos = ssm(SCI_GETCURRENTPOS),
	anchor = ssm(SCI_GETANCHOR),
	count = 0
    -- save the current position to be restored later
    ssm(SCI_SETANCHOR, 0)
    ssm(SCI_SETCURRENTPOS, 0)
    -- search until not found (show error first time only)
    ssm(SCI_BEGINUNDOACTION)
    while search_find(what, 0) do
        search_replace(phrase)
        count += 1
    end while
    ssm(SCI_ENDUNDOACTION)
    ssm(SCI_SETSEL, anchor, pos)
    return count
end function


--------------------------------------
-- tab management
--------------------------------------

global function get_prev_tab()
    if current_tab <= 1 then
        return length(tab_hedits)
    end if
    return current_tab - 1
end function

global function get_next_tab()
    if current_tab >= length(tab_hedits) then
        return 1
    end if
    return current_tab + 1
end function

global function make_tab_name()
    sequence name

    if length(file_name) = 0 then
        name = "New File"
    else
        name = file_name
        for i = length(name) to 1 by -1 do
            if name[i] = '\\' or name[i] = '/' then
                name = name[i+1..$]
                exit
            end if
        end for
    end if
    if modified then name &= "*" end if
    return name
end function


procedure update_tab_timestamp()
    if length(file_name) then
        tab_timestamps[current_tab] = get_timestamp(file_name)
    else
        tab_timestamps[current_tab] = -1
    end if
end procedure 


global procedure select_tab(integer tab)
    if tab < 1 or tab > length(tab_hedits) or tab = current_tab then
        return
    end if
    current_tab = tab
    file_name = tab_file_names[tab]
    hedit = tab_hedits[tab]
    modified = get_modified()
    
    expand_line = -1
    insert_chars = ""
    calltip_args = {}
    calltip_pos = -1
    calltip_stack = {}
    calltip_text = ""

    ui_select_tab(tab)
    ui_update_window_title(file_name)
    update_status()
end procedure

global procedure update_tab_name()
    ui_update_window_title(file_name)
    ui_update_tab_name(current_tab, make_tab_name())
end procedure

global procedure new_tab(sequence file_name)
    integer tab

    if equal(tab_file_names, {""}) and modified = 0 then
        -- unmodified new file, just reuse it and update the tab name
        tab = 1
        tab_file_names[tab] = file_name
        update_tab_name()
        current_tab = 0 -- to force select_tab
    else
        hedit = ui_new_tab(make_tab_name())
        init_edit(hedit)

        tab_hedits = append(tab_hedits, hedit)
        tab_file_names = append(tab_file_names, file_name)
        tab_timestamps = append(tab_timestamps, -1)
        tab_arguments = append(tab_arguments, "")
        tab_pos_stack = append(tab_pos_stack, {})
        tab = length(tab_hedits)
    end if
    select_tab(tab)
end procedure

global procedure close_tab()
    integer tab
    tab = current_tab
    save_recent_pos()
    ui_close_tab(tab)

    tab_hedits = tab_hedits[1..tab-1] & tab_hedits[tab+1..$]
    tab_file_names = tab_file_names[1..tab-1] & tab_file_names[tab+1..$]
    tab_timestamps = tab_timestamps[1..tab-1] & tab_timestamps[tab+1..$]
    tab_arguments = tab_arguments[1..tab-1] & tab_arguments[tab+1..$]
    tab_pos_stack = tab_pos_stack[1..tab-1] & tab_pos_stack[tab+1..$]
    current_tab = 0
    if length(tab_hedits) = 0 then
	new_file() -- must always have a edit available
    elsif tab > length(tab_hedits) then
	tab = length(tab_hedits)
    end if
    select_tab(tab)
end procedure

global function get_tab_arguments()
    return tab_arguments[current_tab]
end function

global procedure set_tab_arguments(sequence s)
    tab_arguments[current_tab] = s
end procedure



--------------------------------------
-- file open/save
--------------------------------------

-- returns tab index of opened file, or 0 if cancelled
global function open_file(sequence file_name, integer reload)
    atom result, text_buffer
    integer fn, tab, initial_pos = 0, first_visible_line = 0
    object temp, s
    sequence text

    if length(file_name) = 0 then
        file_name = ui_get_open_file_name()
        if length(file_name) = 0 then return 0 end if
        if sequence(file_name[1]) then
            -- multiple open
            for i = 1 to length(file_name) do
                open_file(file_name[i], reload)
            end for
            return 0
        end if
    elsif sequence(file_name[1]) then
        -- filename is {"file_name", initial_pos, first_visible_line}
        if length(file_name) >= 2 and integer(file_name[2]) then
	    initial_pos = file_name[2]
        end if
        if length(file_name) >= 3 and integer(file_name[3]) then
	    first_visible_line = file_name[3]
	end if
        file_name = file_name[1]
    end if
    
    file_name = canonical_path(file_name, 0, CORRECT)

    -- check if already existing tab
    tab = find(file_name, tab_file_names)
    if tab and reload = 0 then
      select_tab(tab)
      return tab
    end if

    text = ""
    fn = open(file_name, "rb")
    if fn = -1 then
      -- file couldn't be opened
      if ui_message_box_yes_no("Open", "Unable to open "&file_name&"\n\n"&
                     "Do you want to create it?") = 0 then
	  return 0
      end if
    else
      -- read the contents of the file into text
      s = gets(fn)
      while sequence(s) do
	  text &= s
	  s = gets(fn)
      end while
      close(fn)
    end if

    if not tab then
      new_tab(file_name)
      tab = current_tab
    end if
    update_tab_timestamp()

    result = ssm(SCI_CLEARALL)
    result = ssm(SCI_SETTEXT, 0, text)
    result = ssm(SCI_SETSAVEPOINT)
    modified = 0
    if tab then
      update_tab_name()
    end if
    
    result = ssm(SCI_SETFIRSTVISIBLELINE, first_visible_line)
    result = ssm(SCI_SETEMPTYSELECTION, initial_pos)
    result = ssm(SCI_EMPTYUNDOBUFFER)

    add_recent_file(file_name)
    return tab
end function

-- open files on startup and saved tabs
global procedure open_tabs()
    sequence cmdline
    cmdline = command_line()
    tabs_to_open &= cmdline[3..$]
    -- open files on command line
    for i = 1 to length(tabs_to_open) do
	open_file(tabs_to_open[i], 0)
    end for
    if length(tab_file_names) != 0 and reopen_tabs then
	select_tab(initial_tab)
    else
	new_file()
    end if
end procedure

procedure save_file()
    atom fn, junk

    ssm(SCI_SETSAVEPOINT, 0, 0)
    modified = 0

    fn = open(file_name, "wb")
    puts(fn, get_edit_text())
    close(fn)

    update_tab_name()
    update_tab_timestamp()
end procedure

global function save_file_as()  -- returns 1 if ok, 0 if cancelled
    object temp

    temp = ui_get_save_file_name(file_name)
    if length(temp) = 0 then return 0 end if

    file_name = canonical_path(temp, 0, CORRECT)
    tab_file_names[current_tab] = file_name
    save_file()
    update_tab_name()
    return 1
end function


global function save_if_modified(integer confirm)  -- returns 1 if ok, 0 if cancelled
    atom result, junk
    sequence text
    
    if not get_modified() and length(file_name) != 0 then
       return 1
    end if

    if confirm then
	text = ""
	if length(file_name) then
	    text = " in " & file_name
	end if
	text = "The text"&text&" has changed.\n\nDo you want to save the changes?"
	result = ui_message_box_yes_no_cancel(window_title, text)
	if result != 1 then -- no or cancel
	    return result + 1
	end if
    end if

    if length(file_name) = 0 then
        return save_file_as()
    end if
    save_file()
    return 1
end function

global function save_modified_tabs()  --returns 1 if ok, 0 if cancelled
    integer idx
    atom saved_hedit
    saved_hedit = hedit
    for tab = 1 to length(tab_hedits) do
        hedit = tab_hedits[tab]
        idx = find(tab_file_names[tab], recent_files)
        if idx then
            recent_pos[idx] = get_pos()
        end if
        if get_modified() then
            select_tab(tab)
            if save_if_modified(1) = 0 then
                return 0 -- cancelled
            end if
            saved_hedit = hedit
        end if
    end for
    hedit = saved_hedit
    return 1
end function

global procedure new_file()
    atom junk

    new_tab("")
    ssm(SCI_SETTEXT, 0, "")
    ssm(SCI_SETSAVEPOINT, 0, 0)
end procedure


global procedure check_externally_modified_tabs()
    atom ts
    for i = 1 to length(tab_file_names) do
        if length(tab_file_names[i]) and tab_timestamps[i] != -1 then
            ts = get_timestamp(tab_file_names[i])
            if ts != tab_timestamps[i] then
	          --? {ts, tab_timestamps[i]}
                 -- clear the timestamp here so that don't repeat when the MessageBox retriggers WM_SETFOCUS
		tab_timestamps[i] = -1
                if ui_message_box_yes_no(window_title, tab_file_names[i] & 
                                         "\n\nThis file has been modified by another application.  Do you want to reload it?") then
                    select_tab(i)
                    open_file(tab_file_names[i], 1)
                else
                    tab_timestamps[i] = ts
                end if
            end if
        end if
    end for
end procedure


global procedure add_recent_file(sequence filename)
    integer idx
    idx = find(filename, recent_files)
    if idx then
        -- move it to the top of the list
        recent_files = {recent_files[idx]} & recent_files[1..idx-1] & 
                       recent_files[idx+1..length(recent_files)]
        recent_pos = {recent_pos[idx]} & recent_pos[1..idx-1] &
                      recent_pos[idx+1..length(recent_pos)]   
    else
        idx = length(recent_files)
        if idx >= max_recent_files then
            idx -= 1
        end if
        recent_files = {filename} & recent_files[1..idx]
        recent_pos = {0} & recent_pos[1..idx]
    end if
    ui_refresh_file_menu(recent_files)
end procedure

global procedure save_recent_pos()
    integer idx
    idx = find(file_name, recent_files)
    if idx then
        recent_pos[idx] = get_pos()
    end if
end procedure

global procedure open_recent(integer idx)
    atom junk
    integer tab
    if idx >= 1 and idx <= length(recent_files) then
        tab = open_file(recent_files[idx], 0)
        if tab then
            ssm(SCI_SETSEL, recent_pos[1], recent_pos[1])
            set_top_line(-1) -- set the top visible line to the current line
        end if
    end if
end procedure


--------------------------------------
-- help routines
--------------------------------------

sequence help_dir

global procedure show_help(sequence file, sequence anchor)
    integer ok = 0
    integer f = open(help_dir & file & ".html", "r")
    sequence html = ""
    if f = -1 then
        return
    end if
    object line = gets(f)
    while sequence(line) do
	if match("<a name=", line) = 1 then
	    sequence a = ""
	    for i = 10 to length(line) do
	        if line[i] = '"' then
	            a = line[10..i-1]
	            exit
	        end if
	    end for
	    --puts(1, a&"\n")
	    if equal(a, anchor) then
	        ok = 1
	    elsif ok = 1 and (
		match("_comments", a) or
		match("_example", a) or
		match("_returns", a) or
		match("_parameters", a) or
		match("_platform", a) or
		match("_seealso", a)
	    ) then
		ok = 1
	    else
		ok = 0
	    end if
	end if
	if ok then
	    html &= line
	end if
        line = gets(f)
    end while
    close(f)
    ui_show_help(html)
end procedure

function tr(sequence s, sequence src, sequence dst)
    for i = 1 to length(s) do
        integer x = find(s[i], src)
        if x then
            s[i] = dst[x]
        end if
    end for
    return s
end function

global procedure context_help()
    sequence text, decls, word, name_space, path
    integer pos, junk
    object help

    text = get_edit_text()
    pos = get_pos()
    word = word_pos(text, pos)
    if length(word) < 2 then return end if
    name_space = word[2]
    word = word[1]

    -- load the search.dat file
    if length(search_dat) = 0 then
        sequence paths = include_paths(0)
        for i = 1 to length(paths) do
	    path = paths[i]
	    if path[$] = SLASH then
	        path = path[1..$-1]
	    end if
	    path &= join_path({"..","docs","html"}) & SLASH
	    --puts(1, path&"\n")
	    integer f = open(path & "js" & SLASH & "search.js","r")
	    if f != -1 then
	        help_dir = canonical_path(path)
	        if help_dir[$] != SLASH then
	            help_dir &= SLASH
	        end if
	        object line = gets(f)
	        while sequence(line) do
	            integer x = find(':', line)
	            if x and line[1] = '"' then
			--puts(1, line[2..x-2]&" "&line[x+1..$]&"\n")
	                search_idx = append(search_idx, line[2..x-2])
	                line = tr(line[x+1..$-1], "[]", "{}")
	                line = value(line)
	                search_dat = append(search_dat, line[2])
	            end if
	            line = gets(f)
	        end while
	        close(f)
	        exit
	    end if
        end for
	if length(search_dat) = 0 then
	    ui_message_box_error(window_title, "File not found: euphoria/docs/html/js/search.js")
	    return
	end if
    end if
    
    -- search search.dat for matching entry
    help = {}
    for i = 1 to length(search_idx) do
        if equal(search_idx[i], word) then
            help = search_dat[i]
            exit
        end if
    end for
    if atom(help) or length(help) = 0 then
	return
    end if

    if length(help) > 1 then
	-- multiple help entries
	path = ""
	decls = get_declarations(parse(text, file_name), pos, name_space)
	for j = 1 to length(decls) by 2 do
	  if equal(decls[j], word) then
	    if atom(decls[j+1]) then
	      path = file_name
	    else
	      path = decls[j+1][1]
	    end if
	    
	    for i = 1 to length(help) do
		if match(sreplace(help[i][1],"_",{SLASH})&".e", path) then
		    --show_help(help[i][1], help[i][2])
		    ui_show_uri("file://" & help_dir & help[i][1] & ".html#" & help[i][2])
		    return
		end if
	    end for
	  end if
	end for
    end if

    -- only one help entry, just show it
    --show_help(help[1][1], help[1][2])
    ui_show_uri("file://" & help_dir & help[1][1] & ".html#" & help[1][2])
end procedure

global procedure open_tutorial()
    new_file()
    ssm(SCI_SETTEXT, 0, `
----------------------------------------
-- Welcome to the Wee Euphoria Editor --
----------------------------------------

-- Scintilla Keys:
--
-- Text Size
--   Magnify                         Control keypad +
--   Reduce                          Control keypad -
--   Normal                          Control keypad /
--
-- Cursor Movement
--   Go to start of document         Control Home
--   Go to end of document           Control End
--   Go to start of line             Control Home
--   Go to end of line               Control End
--   Go to previous paragraph        Control Up
--   Go to next paragraph            Control Down
--   Go to previous word             Control Left
--   Go to next word                 Control Right
--   (shift extends selection)
--
-- Delete Text
--    To start of line               Control Shift Backspace
--    To start of word               Control Backspace
--    To end of word                 Control Delete
--
-- Indent
--    Indent block                Tab
--    Unindent block              Shift Tab


-- Wee offers autocompletion for the following keywords.
-- Type a space at the end of each keyword below to see the 
-- expansion.  After the expansion, press Enter to jump over 
-- the "then" or "do" to the next line.

if

-------------------------
while

-------------------------
switch

-------------------------
procedure

-------------------------
function

-------------------------
type

-------------------------
for

-- The "for" keyword also inserts " =  to " but is overtypable,
-- meaning you can continue typing " = " and it will replace the
-- existing characters.  Or you can move your cursor using the 
-- arrow keys.

-- Likewise, pair characters are inserted for typing the following
-- characters: ( [ { " '
-- And you can overtype the closing character if you wish.
-- Pressing "(" results in "()"
-- Typing "123" results in "(123)"
-- Pressing ")" results in "(123)"
-- Try it!

-- Here's a longer example demonstrating the overtype mechanism:

-- type    result 
-- ------- --------------------- 
-- foo[    foo[] 
-- 123     foo[123] 
-- ]       foo[123] 
-- [       foo[123][] 
-- (       foo[123][()] 
-- i+1     foo[123][(i+1)] 
-- )*2     foo[123][(i+1)*2] 
-- ]       foo[123][(i+1)*2] 
--  = {    foo[123][(i+1)*2] = {} 
-- 1, {    foo[123][(i+1)*2] = {1, {}} 
-- "       foo[123][(i+1)*2] = {1, {""}} 
-- bar     foo[123][(i+1)*2] = {1, {"bar"}} 
-- "       foo[123][(i+1)*2] = {1, {"bar"}} 
-- }       foo[123][(i+1)*2] = {1, {"bar"}} 
-- }       foo[123][(i+1)*2] = {1, {"bar"}} 


-- If the initial character is deleted using backspace, the
-- inserted pair will also be removed.  (This does not work 
-- with quotation marks however, only parens and braces.)
-- Pressing "(" results in "()"
-- Pressing backspace results in ""

-- Wee also knows about subroutines you've defined.
-- Press F2 to see a list.  If you've filled in names for the 
-- subroutine declarations above, they should appear.
-- Pressing OK or Enter will move the cursor to the subroutine
-- definition.  If your cursor is on the name of an existing
-- subroutine, it will be the highlighted entry.
-- Try it!  Type the name of a subroutine and hit F2.


-- Autocompletion for any type of identifier is done with
-- Control+Space.  The standard library is also searched for 
-- completions, indicated by "--include" in the list entry, and
-- when selected, the include statement will be inserted 
-- automatically near the top of the file.


-- Typing ':' after a namespace identifier will show an auto-
-- complete list for definitions within a specific namespace.


-- Pressing Ctrl+F2 while on an identifier will move the cursor
-- to the definition of that identifier, and select it.
-- Pressing escape will deselect the text, and pressing escape
-- again will return the cursor to the previous location, think 
-- of it as pressing Back in a web browser.


-- Pressing Shift+F2 while on a subroutine identifier will display
-- a calltips popup.  The popup shows the types and names of the 
-- arguments to the subroutine, with default arguments enclosed in
-- square brackets.


-- Typing '(' after a subroutine identifier will show the calltips
-- popup, and highlight the argument position as you type.


-- Pressing F4 will open a dialog showing the most recent ex.err
-- file, with the error message and a list of either:
--  the call stack of the subroutines at the point of the crash,
--  or a list of undefined symbols.
-- Select an item in the list and press Goto Error to move the 
-- cursor to that location.


-- That's all, have fun!
`)
end procedure



-------------------------------------------------------------------
-- ex.err file handling routines
-------------------------------------------------------------------

-- returns {"filename:line", "message", "line1", "line2", "line3"...}
global function get_ex_err()
    integer fn
    object line, msg, txt
    sequence result, tmp
    
    fn = open(ex_err_name, "r")
    if fn = -1 then
	return {}
    end if
    result = {}
    line = gets(fn) -- filename:line
    if not atom(line) then
        msg = gets(fn)
        result = {line, msg}
        if match("Errors resolving the following references", msg) then
	    txt = gets(fn)
	    while sequence(txt) and length(txt) > 1 do
		result = append(result, txt)
	        txt = gets(fn)
	    end while
        else
	    result = append(result, line)
	    tmp = "... called from "
	    txt = gets(fn)
	    while sequence(txt) and length(result) < 100 do
		if length(txt) > length(tmp) and equal(txt[1..length(tmp)], tmp) then
		    result = append(result, txt[length(tmp)+1..$])
		end if
	        txt = gets(fn)
	    end while
        end if
    end if
    close(fn)
    return result
end function

-- get the text between two delimeters, searching from end of text
function text_between(sequence text, integer delim1, integer delim2)
    for i = length(text) to 1 by -1 do
	if text[i] = delim2 then
	    for j = i-1 to 1 by -1 do
		if text[j] = delim1 then
		    return text[j+1..i-1]
		end if
	    end for
	    exit
	end if
    end for
    return ""
end function

global procedure goto_error(sequence err, integer idx)
    integer a, b, c, line, tab, col
    sequence val, file, item, text
    
    if idx < 0 or idx > length(err)-2 then
        return
    end if
    
    text = err[idx+2]
    
    a = find('(', text)
    b = find(')', text)
    c = 0
    for i = length(text) to 1 by -1 do
        if text[i] = ':' then
            c = i
            exit
        end if
    end for
    item = ""
    if a < c and c < b then
	-- 'blah' (filename:line) has not been declared
	file = dirname(ex_err_name) & SLASH & text[a+1..c-1]
        val = value(text[c+1..b-1])
        item = text_between(text, '\'', '\'')
    elsif c then
	-- c:\path\to\filename.ext:line subroutine_name()
        file = text[1..c-1]
        val = value(text[c+1..$])
        item = text_between(err[2], '\'', '\'')
    else
	return
    end if
    tab = open_file(file, 0)
    if tab and val[1] = GET_SUCCESS then
        line = val[2]-1
	col = 0
        if length(item) then
	    col = match(item, get_line(line))
	    if col then 
		col -= 1
	    else
		item = ""
	    end if
	end if
	col += ssm(SCI_POSITIONFROMLINE, line)
        ssm(SCI_SETSEL, col, col + length(item))
        set_top_line(line)
    end if
end procedure

global procedure view_error()
    atom fn, result
    object s
    integer line, colon, caret, tab
    sequence file, message
    
    ui_view_error()
    return
    
    fn = open("ex.err", "r")
    if fn = -1 then
	return
    end if
    s = gets(fn)  -- "filename:line"
    if atom(s) then
        close(fn)
	return
    end if
    if length(s) < 3 then
        close(fn)
	return
    end if
    colon = match(":", s[3..length(s)]) + 2
    if colon < 3 then
        close(fn)
	return
    end if
    file = s[1..colon-1]
    tab = find(file, tab_file_names)
    if tab then
      select_tab(tab)
    else
	if ui_message_box_yes_no("Goto Error",
		"The file ex.err refers to\n"&file&
		"\n\nDo you want to open this file?")= 0 then
            close(fn)
	    return
	end if
	tab = open_file(file, 0)
    end if
    s = value(s[colon+1..length(s)])
    if s[1] != GET_SUCCESS 
    or not integer(s[2]) then
        close(fn)
	return
    end if
    line = s[2]
    s = gets(fn)
    if atom(s) then
        close(fn)
	return
    end if
    message = s
    s = gets(fn)
    s = gets(fn)
    close(fn)
    if atom(s) then
	return
    end if
    caret = find('^', s)
    caret += ssm(SCI_POSITIONFROMLINE, line-1)
    result = ssm(SCI_SETSEL, caret, caret)
    set_top_line(-1)
    result = ui_message_box_error("Goto Error", message)
end procedure

global procedure reset_ex_err()
    if length(run_file_name) = 0 then
        return
    end if
    ex_err_name = dirname(run_file_name) & SLASH & "ex.err"
    ex_err_timestamp = get_timestamp(ex_err_name)
end procedure

global procedure check_ex_err()
  atom ts

  if length(run_file_name) = 0 then return end if

  ts = get_timestamp(ex_err_name)
--printf(1, "%s %d %d\n", {ex_err_name, ts, ex_err_timestamp})
  if ts > ex_err_timestamp then
    run_file_name = ""
    ui_view_error()
  end if
  ex_err_timestamp = ts
end procedure


-------------------------------------------------------------------
-- code syntax routines
-------------------------------------------------------------------

global procedure view_declaration()
    sequence text, decls, word, name_space
    integer pos
    
    text = get_edit_text()
    pos = get_pos()
    word = word_pos(text, pos)
    if length(word) < 2 then return end if
    name_space = word[2]
    word = word[1]

    decls = get_declarations(parse(text, file_name), pos, name_space)
    for i = 1 to length(decls) do
      if equal(decls[i][1], word) then
        goto_pos(decls[i][2], length(word))
        exit
      end if
    end for
end procedure


global procedure view_completions()
    sequence text, word, decls, name_space, suggestions
    integer pos, junk, style

    pos = get_pos()

    style = ssm(SCI_GETSTYLEAT, pos-2)
    if style = SCE_LUA_STRING or style = SCE_LUA_COMMENTLINE then
        return -- no completion in strings or comments
    end if

    -- use scintilla's code completion
    text = get_edit_text()
    word = word_pos(text, pos)
    if length(word) < 4 then 
	return
    end if
    --printf(1, "word=%s namespace=%s pos=%d end=%d\n", word)
    ssm(SCI_SETSEL, word[4], word[4])
    name_space = word[2]
    word = word[1]

    decls = get_declarations(parse(text, file_name), pos, name_space)
    if length(decls) = 0 or length(name_space) = 0 then
	suggestions = suggest_includes(word, name_space)

	-- filter duplicate suggestions
	for i = 1 to length(suggestions) do
	    if not find(suggestions[i], decls) then
		decls = append(decls, suggestions[i])
	    end if
	end for
    end if
    
    if length(decls) = 0 then
	return
    end if
    text = ""
    for i = 1 to length(decls) do
	if length(decls[i][1]) >= length(word) and equal(decls[i][1][1..length(word)], word) then
	  if length(text) then 
	    text &= "\n"
	  end if
	  text &= decls[i][1] & sprintf("?%d", {decls[i][3]})
	end if
    end for
    if length(text) then
      ssm(SCI_AUTOCSHOW, length(word), text)
    end if
end procedure

-- show the subroutine arguments, usually triggered after a pressing '('
global procedure view_subroutine_arguments()
    sequence text, word, decls, name_space
    integer pos, end_pos, junk, calltip_save, style

    pos = get_pos()
    style = ssm(SCI_GETSTYLEAT, pos-2)
    if style = SCE_LUA_STRING or style = SCE_LUA_COMMENTLINE then
        return -- no completion in strings or comments
    end if

    calltip_save = calltip_pos
    if ssm(SCI_GETCHARAT, pos-1) = '(' then
        calltip_pos = pos
        pos -= 1
    end if

    -- use scintilla's code completion
    text = get_edit_text()
    word = word_pos(text, pos)
    if length(word) < 4 then
        calltip_pos = calltip_save
        return
    end if
    pos = word[3]
    end_pos = word[4]
    name_space = word[2]
    word = word[1]

    decls = get_subroutine_arguments(parse(text, file_name), word, name_space)
    if length(decls) then
        decls = decls[$] -- overloaded?  use the last one
        if calltip_save != -1 then
	    calltip_stack &= {calltip_save, calltip_args, calltip_text}
	    --? calltip_stack
        end if
        text = decls[1] & " " & decls[2] & "("
	calltip_args = {}
        for i = 3 to length(decls) by 3 do
          if i != 3 then text &= ", " end if
          if decls[i+2] then text &= "[" end if
          calltip_args &= {{length(text), 0}}
          text &= decls[i] & " " & decls[i+1]
          calltip_args[$][2] = length(text)
          if decls[i+2] then text &= "]" end if
        end for
        text &= ")"
        --puts(1, text & "\n")
        calltip_text = text
        ssm(SCI_CALLTIPSHOW, pos, text)
        if length(calltip_args) then
            ssm(SCI_CALLTIPSETHLT, calltip_args[1][1], calltip_args[1][2])
        else
	    calltip_pos = -1 -- no arguments, no need to update
        end if
        return
    end if
    
    -- decl not found, search includes instead
    decls = suggest_includes(word, name_space)
    text = ""
    for i = 1 to length(decls) by 2 do
	if length(decls[i]) >= length(word) and equal(decls[i][1..length(word)], word) then
	  if length(text) then
	    text &= '\n'
	  end if
	  text &= sreplace(decls[i], " --", "( --")
	end if
    end for
    if length(text) then
      ssm(SCI_GOTOPOS, end_pos+1)
      ssm(SCI_AUTOCSHOW, length(word)+1, text)
    end if
end procedure


procedure update_subroutine_arguments()
    sequence text
    integer pos, arg, ch
    
    pos = get_pos()-1
 
    ch = ssm(SCI_GETCHARAT, pos, 0)
    if ch != ',' and ch != ')' and ssm(SCI_GETCHARAT, pos+1, 0) != ',' then
        return
    end if
    --? {calltip_pos, pos}
    while 1 do
    
	while calltip_pos = -1 or pos < calltip_pos do
	    if length(calltip_stack) = 0 then
	        calltip_pos = -1
	        return
	    end if
	    calltip_pos = calltip_stack[$-2]
	    calltip_args = calltip_stack[$-1]
	    calltip_text = calltip_stack[$]
	    ssm(SCI_CALLTIPSHOW, calltip_pos, calltip_text)        
	    calltip_stack = calltip_stack[1..$-3]
	end while
	
	-- get the text from after '(' up to the cursor
	text = repeat(0, pos - calltip_pos + 1)
	for i = 1 to length(text) do
	    text[i] = ssm(SCI_GETCHARAT, calltip_pos+i-1)
	end for
	--puts(1, text&"\n")
	
	arg = parse_argument_position(text)
	if arg = 0 then
	    -- parsed closing ')'
	    ssm(SCI_CALLTIPCANCEL)
	    calltip_pos = -1
	elsif arg > length(calltip_args) then
	    -- parsed too many arguments
	    ssm(SCI_CALLTIPSETHLT, 0, 0)
	    exit
	else
	    -- highlight argument at cursor position
	    ssm(SCI_CALLTIPSETHLT, calltip_args[arg][1], calltip_args[arg][2])
	    exit
	end if

    end while
end procedure


function ltrim(sequence s)
  for i = 1 to length(s) do
    if not find(s[i], " \t\n\r") then
      return s[i..$]
    end if
  end for
  return "" 
end function


function rtrim(sequence s)
  for i = length(s) to 1 by -1 do
    if not find(s[i], " \t\n\r") then
      return s[1..i]
    end if
  end for
  return "" 
end function


-- expand "if " to "if  then\n\nend if", etc.
procedure auto_expand()
    sequence text, indent
    integer pos, end_pos
    atom junk

    -- make sure the current position is at the end of the line
    pos = get_pos()
    end_pos = get_line_end_position(-1)
    if pos != end_pos then return end if

    -- save the indentation and trim the line
    indent = get_line(-1)
    text = ltrim(indent)
    indent = "\n" & indent[1..$-length(text)]
    text = rtrim(text)

    -- get the text to insert
    if equal(text, "if") then
        text = {" then", "end if"}
    elsif equal(text, "elsif") or equal(text, "case") then
        text = {" then"}
    elsif equal(text, "while") then
        text = {" do", "end while"}
    elsif equal(text, "loop") then
        text = {"do", "end loop"}
    elsif equal(text, "for") then
        text = {" =  to  do", "end for"}
        --text = {" do", "end for"}
        insert_chars &= " ot  = "
    elsif equal(text, "switch") then
        text = {" do", "end switch"}
        
    else
        if match("global ", text) = 1
        or match("public ", text) = 1
        or match("export ", text) = 1 then
            text = ltrim(text[7..$])
        end if
	if equal(text, "procedure") then
            text = {"()", "end procedure"}
        elsif equal(text, "function") then
            text = {"()", "end function"}
        elsif equal(text, "type") then
            text = {"()", "end type"}
        else
            return
        end if
        insert_chars &= ")("
    end if
    if length(text) = 1 then
        text = text[1] & indent & indent_str
    else
        text = text[1] & indent & indent_str & indent & text[2]
    end if
    
    -- save the line for auto_indent()
    expand_line = ssm(SCI_LINEFROMPOSITION, pos)

    -- insert the text and restore cursor position
    ssm(SCI_INSERTTEXT, pos, text)
end procedure


procedure auto_indent()
    integer line, pos, end_pos
    sequence indent
    atom junk

    -- get the previous line and get the indentation
    pos = get_pos()
    line = ssm(SCI_LINEFROMPOSITION, pos) - 1
    end_pos = get_line_end_position(line)

    if line = expand_line then
        -- delete the newline character and go to end of the next line
	ssm(SCI_DELETERANGE, end_pos, pos - end_pos)
	end_pos = get_line_end_position(line + 1)
	ssm(SCI_GOTOPOS, end_pos)
        expand_line = -1
        return
    end if
    expand_line = -1
    
    -- get the indentation of the previous line, and remove newline
    indent = get_line(line)
    for i = length(indent)-length(ltrim(indent)) to 0 by -1 do
      if i = 0 or (indent[i] != '\n' and indent[i] != '\r') then
        indent = indent[1..i]
        exit
      end if
    end for

    -- insert the indentation
    ssm(SCI_ADDTEXT, length(indent), indent)
end procedure


procedure do_brace_highlight(atom hedit)
  integer pos, brace, ch
  brace = -1
  pos = get_pos()-1
  if find(ssm(SCI_GETCHARAT, pos, 0), "{}()[]") then
    brace = ssm(SCI_BRACEMATCH, pos, 0)
  end if
  if brace = -1 then
    pos += 1
    if find(ssm(SCI_GETCHARAT, pos, 0), "{}()[]") then
      brace = ssm(SCI_BRACEMATCH, pos, 0)
    end if
    if brace = -1 then
      pos = -1
    end if
  end if
  brace = ssm(SCI_BRACEHIGHLIGHT, pos, brace)
end procedure
-- FIXME: this has a problem with brace chars within strings, for ex: {1, "}{", 2}


procedure auto_complete_selection(integer pos, sequence text)
    integer inc, len, insert_line, arg
    sequence line
    
    -- insert include statement if completion contains it
    inc = match(" --include", text)
    if inc then
        ssm(SCI_AUTOCCANCEL, 0, 0)

	len = get_pos() - pos

        arg = text[inc-1] = '('
        if arg then
	    -- delete the existing '(' since we are adding another one
	    len -= 1
            ssm(SCI_DELETERANGE, pos + len, 1)
        end if
        
	if len+1 <= inc then
	    ssm(SCI_ADDTEXT, inc-1-len, text[len+1..inc])
        end if
        text = text[inc+3..$] & "\n"

	-- search first few lines for include statements
	insert_line = -1
	for i = 0 to 100 do
	    line = ltrim(get_line(i))
	    --printf(1, "%d %d %s\n", insert_line
	    if length(line) >= 8 and equal(line[1..8], "include ") then
	        insert_line = i+1
	    elsif insert_line != -1 then
	        exit
	    end if
	end for
	if insert_line = -1 then
	    -- insert after consecutive comment lines
	    insert_line = 0
	    for i = 0 to 100 do
		line = ltrim(get_line(i))
	        if length(line) >= 2 and line[1]='-' and line[2]='-' then
		    insert_line = i+1
		else
		    exit
		end if
	    end for
	end if
	inc = ssm(SCI_POSITIONFROMLINE, insert_line, 0)
	if inc = -1 or inc > pos then
	    inc = 0
	end if
	ssm(SCI_INSERTTEXT, inc, text)
	if arg then
	    view_subroutine_arguments()
	end if
    end if
end procedure

-- insert closing character when user types ( [ { ' "
procedure insert_pair()
    integer pos, style, ch

    pos = get_pos()-1

    -- avoid inside strings and comments
    if pos != get_line_start_position(-1) then
	style = ssm(SCI_GETSTYLEAT, pos-1)
	if style = SCE_LUA_COMMENTLINE or 
	  (style = SCE_LUA_STRING and 
	   style = ssm(SCI_GETSTYLEAT, pos+1)) then
	    return
	end if
    end if

    -- avoid inside words or numbers
    for i = pos+1 to get_line_end_position(-1) do
	ch = ssm(SCI_GETCHARAT, i)
	style = ssm(SCI_GETSTYLEAT, i)
	--? {ch, style}
	if find(ch, ",)}]\r\n+-*/=!<>#&\0") or style = SCE_LUA_WORD then
	    exit
	elsif ch != ' ' and ch != '\t' then
	    return
	end if
    end for
    ch = ssm(SCI_GETCHARAT, pos, 0)
    if ch = '(' then
	ch = ')'
    elsif ch = '{' then
	ch = '}'
    elsif ch = '[' then
	ch = ']'
    end if
    ssm(SCI_INSERTTEXT, pos+1, {ch})
    insert_chars &= ch
end procedure

-- remove the characters inserted by insert_pair(), won't work for ' " tho
procedure delete_pair()
    if length(insert_chars) = 0 then
	return
    end if
    if insert_chars[$] = last_deleted_char then
	insert_chars = insert_chars[1..$-1]
    elsif (last_deleted_char = '(' and insert_chars[$] = ')') or
          (last_deleted_char = '[' and insert_chars[$] = ']') or
          (last_deleted_char = '{' and insert_chars[$] = '}') then
	ssm(SCI_DELETERANGE, get_pos(), 1)
	insert_chars = insert_chars[1..$-1]
    end if
end procedure

-- open file(s) from a drag and drop operation
procedure open_uri(sequence uri)
    uri = split(uri, "\r\n")
    for i = 1 to length(uri) do
        if match("file://", uri[i]) = 1 then
            open_file(uri[i][8..$], 0)
        end if
    end for
end procedure

-- toggle the comment at the start of each line in selection
global procedure toggle_comment()
    integer
	pos = ssm(SCI_GETCURRENTPOS),
	anchor = ssm(SCI_GETANCHOR),
	line_pos = ssm(SCI_LINEFROMPOSITION, pos),
	line_anchor = ssm(SCI_LINEFROMPOSITION, anchor),
	col_pos = pos - ssm(SCI_POSITIONFROMLINE, line_pos),
	col_anchor = anchor - ssm(SCI_POSITIONFROMLINE, line_anchor),
	line_start = ssm(SCI_LINEFROMPOSITION, ssm(SCI_GETSELECTIONSTART)),
	line_end = ssm(SCI_LINEFROMPOSITION, ssm(SCI_GETSELECTIONEND)-1)
    integer uncomment = 1
    if line_end < line_start then
        line_end = line_start
    end if
    -- check to see if all lines are commented
    for i = line_start to line_end do
	pos = ssm(SCI_POSITIONFROMLINE, i)
        if ssm(SCI_GETCHARAT, pos) != '-' or 
           ssm(SCI_GETCHARAT, pos+1) != '-' then
	    uncomment = 0 -- non comment detected
	    exit
        end if
    end for
    ssm(SCI_BEGINUNDOACTION)
    for i = line_start to line_end do
	pos = ssm(SCI_POSITIONFROMLINE, i)
        if uncomment then
	    ssm(SCI_DELETERANGE, pos, 2)
        else
	    ssm(SCI_INSERTTEXT, pos, "--")
        end if
    end for
    ssm(SCI_ENDUNDOACTION)
    pos = ssm(SCI_POSITIONFROMLINE, line_pos) + col_pos
    anchor = ssm(SCI_POSITIONFROMLINE, line_anchor) + col_anchor
    if col_pos != 0 then
        pos -= uncomment*4-2
    end if
    if col_anchor != 0 then
        anchor -= uncomment*4-2
    end if
    ssm(SCI_SETSEL, anchor, pos) 
end procedure

-------------------------------------------------------------------
-- scintilla editor notifications
-------------------------------------------------------------------

procedure log_notification(atom notification)
  integer code, pos, ch, modifiers
  --? peek4u({notification, 24})
  code = peek4u(notification+8)
  pos = peek4u(notification+12)
  if code = SCN_STYLENEEDED then
    puts(1, "SCN_STYLENEEDED\n")
  elsif code = SCN_CHARADDED then
    ch = peek4s(notification+16)
    printf(1, "SCN_CHARADDED ch=%d '%s'\n", {ch, {ch}})
  elsif code = SCN_SAVEPOINTREACHED then
    puts(1, "SCN_SAVEPOINTREACHED\n")
  elsif code = SCN_SAVEPOINTLEFT then
    puts(1, "SCN_SAVEPOINTLEFT\n")
  elsif code = SCN_MODIFYATTEMPTRO then
    puts(1, "SCN_MODIFYATTEMPTRO\n")
  elsif code = SCN_KEY then
    ch = peek4s(notification+16)
    modifiers = peek4s(notification+20)
    printf(1, "SCN_KEY ch=%d modifiers=#%x\n", {ch, modifiers})
  elsif code = SCN_DOUBLECLICK then
    puts(1, "SCN_DOUBLECLICK\n")
  elsif code = SCN_UPDATEUI then
    printf(1, "SCN_UPDATEUI updated=#%x\n", {peek4s(notification+88)})
  elsif code = SCN_MODIFIED then
    puts(1, "SCN_MODIFIED\n")
  elsif code = SCN_MACRORECORD then
    puts(1, "SCN_MACRORECORD\n")
  elsif code = SCN_MARGINCLICK then
    puts(1, "SCN_MARGINCLICK\n")
  elsif code = SCN_NEEDSHOWN then
    puts(1, "SCN_NEEDSHOWN\n")
  elsif code = SCN_PAINTED then
    --gets sent after each caret blink
    --puts(1, "SCN_PAINTED\n")
  elsif code = SCN_USERLISTSELECTION then
    puts(1, "SCN_USERLISTSELECTION\n")
  elsif code = SCN_URIDROPPED then
    puts(1, "SCN_URIDROPPED\n")
  elsif code = SCN_DWELLSTART then
    puts(1, "SCN_DWELLSTART\n")
  elsif code = SCN_DWELLEND then
    puts(1, "SCN_DWELLEND\n")
  elsif code = SCN_ZOOM then
    puts(1, "SCN_ZOOM\n")
  elsif code = SCN_HOTSPOTCLICK then
    puts(1, "SCN_HOTSPOTCLICK\n")
  elsif code = SCN_HOTSPOTDOUBLECLICK then
    puts(1, "SCN_HOTSPOTDOUBLECLICK\n")
  elsif code = SCN_HOTSPOTRELEASECLICK then
    puts(1, "SCN_HOTSPOTRELEASECLICK\n")
  elsif code = SCN_INDICATORCLICK then
    puts(1, "SCN_INDICATORCLICK\n")
  elsif code = SCN_INDICATORRELEASE then
    puts(1, "SCN_INDICATORRELEASE\n")
  elsif code = SCN_CALLTIPCLICK then
    puts(1, "SCN_CALLTIPCLICK\n")
  elsif code = SCN_AUTOCSELECTION then
    puts(1, "SCN_AUTOCSELECTION\n")
  elsif code = SCN_AUTOCCANCELLED then
    puts(1, "SCN_AUTOCCANCELLED\n")
  elsif code = SCN_AUTOCCHARDELETED then
    puts(1, "SCN_AUTOCCHARDELETED\n")
  elsif code = SCN_FOCUSIN then
    puts(1, "SCN_FOCUSIN\n")
  elsif code = SCN_FOCUSOUT then
    puts(1, "SCN_FOCUSOUT\n")
  end if
end procedure


ifdef BITS64 then
constant
  NOTIFICATION_CODE = 16,
  NOTIFICATION_POS = 24,
  NOTIFICATION_CH = 28,
  NOTIFICATION_MODIFIERS = 32,
  NOTIFICATION_MODIFICATIONTYPE = 36,
  NOTIFICATION_TEXT = 40,
  NOTIFICATION_LENGTH = 48,
  NOTIFICATION_UPDATED = 116
elsedef
constant
  NOTIFICATION_CODE = 8,
  NOTIFICATION_POS = 12,
  NOTIFICATION_CH = 16,
  NOTIFICATION_MODIFIERS = 20,
  NOTIFICATION_MODIFICATIONTYPE = 24,
  NOTIFICATION_TEXT = 28,
  NOTIFICATION_LENGTH = 32,
  NOTIFICATION_UPDATED = 88
end ifdef

function notification_text(atom notification)
    ifdef BITS64 then
	return peek_string(peek8u(notification+NOTIFICATION_TEXT))
    elsedef
	return peek_string(peek4u(notification+NOTIFICATION_TEXT))
    end ifdef
end function



global function sci_notify(atom hedit, atom data, atom notification, atom userdata)
  integer code, pos, ch, modifiers, updated, len
  
  --? {ctl, data, notification, userdata}
  if notification = 0 then return 0 end if
  --log_notification(notification)
  code = peek4u(notification+NOTIFICATION_CODE)
  if code = SCN_UPDATEUI then
    updated = peek4u(notification+NOTIFICATION_UPDATED)
    --? {updated, insert_chars, last_deleted_char}
    if and_bits(updated, SC_UPDATE_SELECTION+SC_UPDATE_CONTENT) = SC_UPDATE_SELECTION then
	-- selection moved and content was not changed
	--? {updated, insert_chars}
	insert_chars = ""
    elsif last_deleted_char then
	delete_pair()
        last_deleted_char = 0
    end if
    if ssm(SCI_CALLTIPACTIVE) then
        update_subroutine_arguments()
    end if
    update_status()
    do_brace_highlight(hedit)

  elsif code = SCN_SAVEPOINTREACHED or code = SCN_SAVEPOINTLEFT then
    modified = (code = SCN_SAVEPOINTLEFT)
    update_tab_name()

  elsif code = SCN_KEY then
    ch = peek4s(notification+NOTIFICATION_CH)
    modifiers = peek4s(notification+NOTIFICATION_MODIFIERS)
    -- on OSX, META and SHIFT are the only modifiers we receive
    
    if ch = 'Z' and and_bits(modifiers, SCMOD_CTRL+SCMOD_META) then
      if and_bits(modifiers, SCMOD_SHIFT) then
        ssm(SCI_REDO, 0, 0)
      else
        ssm(SCI_UNDO, 0, 0)
      end if

    elsif ch >= '1' and ch <= '9' and and_bits(modifiers, SCMOD_ALT+SCMOD_META) then
      select_tab(ch - '0')

    elsif ch < 128 then
      --printf(1, "SCN_KEY ch=%d '%s' modifiers=%d\n", {ch, {ch}, modifiers})
    else
      --printf(1, "SCN_KEY ch=#%x modifiers=%d\n", {ch, modifiers})
    end if

  elsif code = SCN_CHARADDED then
    ch = peek4s(notification+NOTIFICATION_CH)
    --printf(1, "SCN_CHARADDED ch=%d '%s'\n", {ch, {ch}})

    if length(insert_chars) and ch = insert_chars[$] then
	-- the user retyped the insert character, so delete it
        ssm(SCI_DELETERANGE, get_pos(), 1)
        -- the UPDATEUI will remove the insert_chars[$]
    elsif ch = ':' then
      view_completions()
    elsif ch = ' ' then
      auto_expand()
    elsif ch = '\n' then
      auto_indent()
    elsif ch = '(' then
      -- check for displaying subroutine arguments
      insert_pair()
      view_subroutine_arguments()
    elsif ch = '{' or ch = '[' then
      insert_pair()
    elsif ch = '"' or ch = '\'' then
      insert_pair()
    end if

  elsif code = SCN_AUTOCSELECTION then
    -- check for "--include" in selection, then add include statement near top of file
    --  or after the first non-commented line, or ideally with other includes
    pos = peek4u(notification+NOTIFICATION_POS)
    auto_complete_selection(pos, notification_text(notification))
    
  elsif code = SCN_MODIFIED then
    modifiers = peek4u(notification+NOTIFICATION_MODIFICATIONTYPE)
    if and_bits(modifiers, SC_MOD_BEFOREDELETE) then
	pos = peek4u(notification+NOTIFICATION_POS)
	len = peek4u(notification+NOTIFICATION_LENGTH)
	--? {modifiers, pos, len}
	if len = 1 then
	    last_deleted_char = ssm(SCI_GETCHARAT, pos)
	end if
    end if

  elsif code = SCN_URIDROPPED then
    open_uri(notification_text(notification))
    
  end if
  return 0
end function
