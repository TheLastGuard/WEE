-- Wee Euphoria Editor
-- 
-- Copyright (c) 1998-2015  Pete Eberlein
-- 
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
-- 
-- The above copyright notice and this permission notice shall be included in
-- all copies or substantial portions of the Software.
-- 
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-- THE SOFTWARE.

global constant
  window_title = "Wee Euphoria Editor",
  author = "Pete Eberlein <pete.eberlein@gmail.com>",
  version = "0.24"

-- revision notes:
--  added: syntax coloring!
--  bug fixed: save mode changed to "wb" (Thanks Lucius)
--  added: replace all
--  added: goto error
--  fixed: hotkeys
--  added: cursor position
--  added: recent files list
--  added: saving window pos+size and recent files to "wee_conf.txt"
--  added: subroutines list dialog (F2)
--  added: choose font dialog (we suggest "Consolas" 11pt)
--  added: tabs (can be selected using Alt+1..9)
--  added: watch tabs for changes to files and ex.err
--  added: goto declaration (Ctrl+F2) and view completions (Ctrl+Space)
--  added: Scintilla edit control (using Lua lexer :/)
--  added: view completions will search std includes
--  added: Search->Find will remember last phrase
--  added: auto expansions for "if" "while" "for" and subroutines (thanks dcuny)
--  added: auto indent newlines
--  added: type ':' to autocomplete a namespace
--  added: auto-complete with include puts it near top of file
--  added: auto insert closing characters for ( { [ " '
--  added: typing '(' after a subroutine will popup hints
--  added: hardcoded list of builtins and arguments in get_subroutine_arguents()
--  updated: ex.err dialog with buttons: <cancel> <open ex.err> <goto error>
--    and listbox with call stack or multiple undeclared references
--  updated: indent/unindent selection with tab/shift-tab
--  Linux/Mac (using EuGTK)
--  store syntax highlighting colors in wee.conf
--  context-sensitive help (hit F1 on a word)
--  saved run arguments
--  move options to separate menu
--  option to sort subroutines in View Subroutines dialog
--  added Bind, Shroud and Translate to Run menu
--  dialog to change syntax highlighting colors
--  popup menu on tab control
--  drag'n'drop files

--  bugs fixed:
--    ViewDeclaration wrong cursor pos
--    audible ding when pressing Alt+1..9
--    ViewCompletions on whitespace crash
--    parser updates cache for modified include files
--    files are now opened in binary mode since scintilla can handle any line endings
--    fixed tab names not updating when save-as
--    fixed "too many open files" error, wasn't closing files in view_error function
--    fixed parsing ifdefs
--    fixed crash after changing font (thanks euphoric)
--    reloading a file that is modified externally loads into wrong tab (thanks dcuny)
--    autocomplete avoids activating inside comments and strings
--    fix weirdness with deletion autoinserted closing characters
--    fix calltip popup displaying incorrect highlight after first time
--    fix EOL mode on Linux/OSX
--    completions are now sorted
--    switch/case syntax highlight and autocomplete were missing
--    shift-ctrl-Z does redo
--    better at locating scintilla library when bound/compiled
--    run/bind/shroud/translate didn't like spaces in the path

-- todo:
--  esc to return to previous location
--  save tabs in conf file? option to restore last tabs?
--  comment/uncomment selected lines
--  fill in Find dialog with current selection
--  choose which intepreter to use for run (interpreter_path)
--  64-bit safe on Windows (Linux/OSX ok)
--  bug with reloading files, first few characters get garbled
--  expanding "for" should then tab between "=", "to", and "do"
--    as it is now, its really annoying
--  fix brace highlighting in comments and strings
--  configurable indent size
--  namespaces still need to be fixed (include as)
--  put an icon in the completion list for each type of symbol (maybe)
--  put arguments after each subroutine completion (maybe)
--  investigate Mike Duffy's scintilla Euphoria Lexer
--    multicolored brackets and parens
--    multiline comments and strings
--  code-aware identifier rename

without warning

include parser.e
include scintilla.e
include get.e
include std/filesys.e
include std/sequence.e
include misc.e


-- The ui includes are circular includes: 
--      wee.exw -> ui_win.e -> wee.exw
-- The ui include is responsible for calling wee_init() and startup.
ifdef WINDOWS then
include ui_win.e
elsedef
include ui_gtk.e
end ifdef

-- all variables must be initialized in wee_init() due to circular include
constant 
    indent_size = 4 -- TODO: make this user configurable
global constant max_recent_files = 5
global atom x_pos, y_pos, x_size, y_size
global sequence font_name
global integer font_height, line_numbers, sorted_subs
global sequence file_name, run_file_name, ex_err_name, recent_files, interpreter_path
global integer keyword_color, builtin_color, string_color,
    comment_color, number_color, normal_color, background_color,
    linenumber_color, bracelight_color
    

-- local variables
sequence
	tab_hedits, tab_file_names, tab_timestamps, 
	recent_pos, indent_str, tab_arguments
integer current_tab, modified
atom hedit
atom ex_err_timestamp
integer expand_line, last_deleted_char
sequence insert_chars
sequence calltip_args -- {{start,end},...}
integer calltip_pos
sequence calltip_stack -- {calltip_pos, calltip_args...}
sequence calltip_text -- "routine_name(type1 arg1, ...)"
sequence wee_conf_filename
sequence search_idx, search_dat

-- shorthand helper function
function ssm(integer m, object w=0, object l=0)
    return scintilla_send_message(hedit, m, w, l)
end function


function crash_cleanup(object x)
  ui_message_box_error(window_title,
    "Houston, Wee have a problem.\n\n" &
    "The editor crashed and is closing now.\n")
  save_modified_tabs()
  if length(wee_conf_filename) then
    save_wee_conf(wee_conf_filename)
  end if
  return 0
end function


constant             -- colors of various syntax classes
    Black = #000000,
    Gray = #AAAAAA,
    DGray = #808080,
    Green = #00AA00,
    Yellow = #88FFFF,
    Magenta = #AA00AA,
    Cyan = #AAAA00,
    Red = #0000AA,
    Blue = #AA0000,
    LightBlue = #FFFFDD,
    White = #FFFFFF

global procedure wee_init()

  wee_conf_filename = ""

  crash_routine(routine_id("crash_cleanup"))

  recent_files = {}
  recent_pos = {}

  font_name = ""
  font_height = 10
  line_numbers = 0
  sorted_subs = 0

  file_name = ""
  hedit = 0
  
  run_file_name = ""
  ex_err_name = "ex.err"
  ex_err_timestamp = get_timestamp(ex_err_name)
  interpreter_path = "eui"

  tab_hedits = {}
  tab_file_names = {}
  tab_timestamps = {}
  tab_arguments = {}

  modified = 0
  expand_line = -1
  insert_chars = ""
  last_deleted_char = 0

  indent_str = repeat(' ', indent_size)
  calltip_args = {}
  calltip_pos = -1
  calltip_stack = {}
  calltip_text = ""
  
  current_tab = 0

  normal_color = Black
  background_color = White
  comment_color = DGray
  number_color = Black
  keyword_color = Green
  builtin_color = Magenta
  string_color = Blue
  bracelight_color = LightBlue
  linenumber_color = DGray

  search_idx = {}
  search_dat = {}

end procedure



global procedure load_wee_conf(sequence wee_conf_file)
    integer f, eq
    object l
    sequence key, val
    f = open(wee_conf_file, "r")
    if f = -1 then return end if
    wee_conf_filename = wee_conf_file
    l = gets(f)
    while sequence(l) do
        eq = find('=', l)
        if eq then
            key = l[1..eq-1]
            val = l[eq+1..length(l)-1]
            l = value(val)
            if equal(key, "x_pos") then
                x_pos = l[2]
            elsif equal(key, "y_pos") then
                y_pos = l[2]
            elsif equal(key, "x_size") then
                x_size = l[2]
            elsif equal(key, "y_size") then
                y_size = l[2]
            elsif equal(key, "recent_file") then
                recent_files &= {val}
            elsif equal(key, "recent_pos") then
                recent_pos &= l[2]
            elsif equal(key, "font_name") then
                font_name = val
            elsif equal(key, "font_height") then
                font_height = l[2]
                if font_height < 0 then 
                    font_height = -floor((font_height*96+36)/72)
                end if
            elsif equal(key, "line_numbers") then
                line_numbers = l[2]
            elsif equal(key, "normal_color") then
                normal_color = l[2]
            elsif equal(key, "background_color") then
                background_color = l[2]
            elsif equal(key, "comment_color") then
                comment_color = l[2]
            elsif equal(key, "keyword_color") then
                keyword_color = l[2]
            elsif equal(key, "builtin_color") then
                builtin_color = l[2]
            elsif equal(key, "number_color") then
                number_color = l[2]
            elsif equal(key, "linenumber_color") then
                linenumber_color = l[2]
            elsif equal(key, "bracelight_color") then
                bracelight_color = l[2]
            elsif equal(key, "sorted_subs") then
                sorted_subs = l[2]
            end if
        end if
        l = gets(f)
    end while
    close(f)
end procedure

global procedure save_wee_conf(sequence wee_conf_file)
    integer f
    f = open(wee_conf_file, "w")
    printf(f, "x_pos=%d\ny_pos=%d\nx_size=%d\ny_size=%d\nline_numbers=%d\n", 
	{x_pos, y_pos, x_size, y_size, line_numbers})
    for i = 1 to length(recent_files) do
        puts(f, "recent_file="&recent_files[i]&"\n")
        printf(f, "recent_pos=%d\n", {recent_pos[i]})
    end for
    if length(font_name) and font_height != 0 then
      printf(f, "font_name=%s\nfont_height=%d\n", {font_name, font_height})
    end if
    printf(f, "normal_color=#%06x\n", {normal_color})
    printf(f, "background_color=#%06x\n", {background_color})
    printf(f, "keyword_color=#%06x\n", {keyword_color})
    printf(f, "builtin_color=#%06x\n", {builtin_color})
    printf(f, "comment_color=#%06x\n", {comment_color})
    printf(f, "number_color=#%06x\n", {number_color})
    printf(f, "string_color=#%06x\n", {string_color})
    printf(f, "linenumber_color=#%06x\n", {linenumber_color})
    printf(f, "bracelight_color=#%06x\n", {bracelight_color})
    printf(f, "sorted_subs=%d\n", {sorted_subs})
    close(f)
end procedure



function sreplace(sequence text, sequence what, sequence replacement)
    integer i
    i = match(what, text)
    if i then
        return text[1..i-1] & replacement & text[i+length(what)..$]
    end if
    return text
end function

-- init edit, (or reinit all existing edits when hedit = 0)
global procedure init_edit(atom edit)
    sequence font
    
    hedit = edit
    
    --? {hedit, ssm(SCI_GETIDENTIFIER, 0, 0)}
    font = font_name
    ifdef not WINDOWS then
	font = sreplace(font, "Medium", "")
	font = sreplace(font, "Thin", "")
	font = sreplace(font, "Bold", "")
	font = sreplace(font, "Italic", "")
	font = sreplace(font, "Condensed", "")
	font = rtrim(font)
	--puts(1, font&".\n")
    end ifdef

    ssm(SCI_STYLESETFONT, STYLE_DEFAULT, font)
    ifdef not WINDOWS then
      ssm(SCI_STYLESETBOLD, STYLE_DEFAULT, match(" Bold", font_name))
      ssm(SCI_STYLESETITALIC, STYLE_DEFAULT, match(" Italic", font_name))
    end ifdef
    ssm(SCI_STYLESETSIZE, STYLE_DEFAULT, font_height)
    ssm(SCI_STYLESETFORE, STYLE_DEFAULT, normal_color)
    ssm(SCI_STYLESETBACK, STYLE_DEFAULT, background_color)
    ssm(SCI_STYLECLEARALL)

    ssm(SCI_SETLEXER, SCLEX_LUA)
    ssm(SCI_SETKEYWORDS, 0, 
     "procedure function type end and or xor not if then elsif else for to by do while "&
     "global constant include with without return exit " &
     -- OE4
     "public export enum as namespace ifdef elsifdef elsedef "&
     "label entry break continue loop until routine switch case fallthru"
     )
    ssm(SCI_SETKEYWORDS, 1, get_builtins())

    ssm(SCI_STYLESETFORE, SCE_LUA_COMMENT, comment_color)
    ssm(SCI_STYLESETFORE, SCE_LUA_COMMENTLINE, comment_color)
    ssm(SCI_STYLESETFORE, SCE_LUA_NUMBER, number_color)
    ssm(SCI_STYLESETFORE, SCE_LUA_WORD, keyword_color)
    ssm(SCI_STYLESETFORE, SCE_LUA_WORD2, builtin_color)
    ssm(SCI_STYLESETFORE, SCE_LUA_STRING, string_color)

    ssm(SCI_STYLESETBACK, STYLE_BRACELIGHT, bracelight_color)
    ssm(SCI_STYLESETBOLD, STYLE_BRACELIGHT, 1)
    
    ssm(SCI_STYLESETFORE, STYLE_LINENUMBER, linenumber_color)
    ssm(SCI_SETMARGINWIDTHN, 0, 48*line_numbers) -- line numbers margin visible
    ssm(SCI_SETMARGINWIDTHN, 1, 0) -- non-folding symbols margin hidden
    
    ssm(SCI_SETINDENT, indent_size)

    ssm(SCI_AUTOCSETSEPARATOR, '\n')
    ssm(SCI_AUTOCSTOPS, 0, " ")
    ssm(SCI_AUTOCSETFILLUPS, 0, "")
    --ssm(SCI_AUTOCSETORDER, SC_ORDER_CUSTOM) -- declaration order
    ssm(SCI_AUTOCSETORDER, SC_ORDER_PERFORMSORT) -- scintilla should sort
    ssm(SCI_AUTOCSETCANCELATSTART)

    -- call tips display above text
    --ssm(SCI_CALLTIPSETPOSITION, 1)

    -- get modification events for deletetext
    ssm(SCI_SETMODEVENTMASK, SC_MOD_BEFOREDELETE)

    ifdef WINDOWS then
	ssm(SCI_SETEOLMODE, SC_EOL_CRLF)
    elsedef
	ssm(SCI_SETEOLMODE, SC_EOL_LF)
    end ifdef
end procedure

global procedure reinit_all_edits()
    atom saved_hedit
    saved_hedit = hedit
    for i = 1 to length(tab_hedits) do
        init_edit(tab_hedits[i])
    end for
    hedit = saved_hedit
end procedure

-- pos is integer position in current tab, or {"filename", pos}
-- note: first character in document is at pos=1
global procedure goto_pos(object pos, integer len=0)
    if sequence(pos) then
	if open_file(pos[1], 0) = 0 then
	    return
	end if
	pos = pos[2]
    end if
    pos -= 1
    ssm(SCI_SETSEL, pos, pos + len)
    set_top_line(-1)
end procedure

global procedure goto_prev_pos()
    
end procedure

global function get_pos()
    return ssm(SCI_GETCURRENTPOS)
end function

global procedure set_top_line(integer line)
    integer fv, los
    if line = -1 then
        line = ssm(SCI_LINEFROMPOSITION, get_pos())
        fv = ssm(SCI_GETFIRSTVISIBLELINE)
        los = ssm(SCI_LINESONSCREEN)
        if line >= fv and line < fv + los-1 then
            return -- don't need to scroll
        end if
    end if
    line = ssm(SCI_SETFIRSTVISIBLELINE, line)
end procedure

global function get_modified()
    return ssm(SCI_GETMODIFY)
end function

global function get_line_length(integer line)
    if line = -1 then
        line = ssm(SCI_LINEFROMPOSITION, get_pos())
    end if
    return ssm(SCI_LINELENGTH, line)
end function

global function get_line_end_position(integer line)
    if line = -1 then
        line = ssm(SCI_LINEFROMPOSITION, get_pos())
    end if
    return ssm(SCI_GETLINEENDPOSITION, line)
end function

global function get_line_start_position(integer line)
    if line = -1 then
        line = ssm(SCI_LINEFROMPOSITION, get_pos())
    end if
    return ssm(SCI_POSITIONFROMLINE, line)
end function


global function get_line(integer line)
    atom junk, len, buf
    sequence text

    if line = -1 then
        line = ssm(SCI_LINEFROMPOSITION, get_pos())
    end if
    len = get_line_length(line)
    buf = allocate(len+1)
    ssm(SCI_GETLINE, line, buf)
    text = peek({buf, len})
    free(buf)
    return text
end function

global function get_edit_text()
    atom junk, text_buffer, text_len
    sequence text

    text_len = ssm(SCI_GETTEXTLENGTH)+1
    text_buffer = allocate(text_len)
    ssm(SCI_GETTEXT, text_len, text_buffer)
    text = peek({text_buffer, text_len-1})
    free(text_buffer)
    return text
end function

global procedure update_status()
    atom pos, line, col
    pos = get_pos()
    line = 1+ssm(SCI_LINEFROMPOSITION, pos)
    col = 1+ssm(SCI_GETCOLUMN, pos)
    ui_update_status(sprintf("%d:%d ", {line, col}))
    if line-1 != expand_line then
        expand_line = -1
    end if
end procedure


global function get_prev_tab()
    if current_tab <= 1 then
        return length(tab_hedits)
    end if
    return current_tab - 1
end function

global function get_next_tab()
    if current_tab >= length(tab_hedits) then
        return 1
    end if
    return current_tab + 1
end function

global function make_tab_name()
    sequence name

    if length(file_name) = 0 then
        name = "New File"
    else
        name = file_name
        for i = length(name) to 1 by -1 do
            if name[i] = '\\' or name[i] = '/' then
                name = name[i+1..$]
                exit
            end if
        end for
    end if
    if modified then name &= "*" end if
    return name
end function


procedure update_tab_timestamp()
    if length(file_name) then
        tab_timestamps[current_tab] = get_timestamp(file_name)
    else
        tab_timestamps[current_tab] = -1
    end if
end procedure 


global procedure select_tab(integer tab)
    if tab < 1 or tab > length(tab_hedits) or tab = current_tab then
        return
    end if
    current_tab = tab
    file_name = tab_file_names[tab]
    hedit = tab_hedits[tab]
    modified = get_modified()
    
    expand_line = -1
    insert_chars = ""
    calltip_args = {}
    calltip_pos = -1
    calltip_stack = {}
    calltip_text = ""

    ui_select_tab(tab)
    ui_update_window_title(file_name)
    update_status()
end procedure

global procedure update_tab_name()
    ui_update_window_title(file_name)
    ui_update_tab_name(current_tab, make_tab_name())
end procedure

global procedure new_tab(sequence file_name)
    integer tab

    if equal(tab_file_names, {""}) and modified = 0 then
        -- unmodified new file, just reuse it and update the tab name
        tab = 1
        tab_file_names[tab] = file_name
        update_tab_name()
        current_tab = 0 -- to force select_tab
    else
        hedit = ui_new_tab(make_tab_name())
        init_edit(hedit)

        tab_hedits = append(tab_hedits, hedit)
        tab_file_names = append(tab_file_names, file_name)
        tab_timestamps = append(tab_timestamps, -1)
        tab_arguments = append(tab_arguments, "")
        tab = length(tab_hedits)
    end if
    select_tab(tab)
end procedure

-- returns tab index of opened file, or 0 if cancelled
global function open_file(sequence file_name, integer reload)
    atom result, text_buffer
    integer fn, tab
    object temp, s
    sequence text

    if length(file_name) = 0 then
        file_name = ui_get_open_file_name()
        if length(file_name) = 0 then return 0 end if
        if sequence(file_name[1]) then
            -- multiple open
            for i = 1 to length(file_name) do
                open_file(file_name[i], reload)
            end for
            return 0
        end if
    end if
    
    file_name = canonical_path(file_name, 0, CORRECT)

    -- check if already existing tab
    tab = find(file_name, tab_file_names)
    if tab and reload = 0 then
      select_tab(tab)
      return tab
    end if

    text = ""
    fn = open(file_name, "rb")
    if fn = -1 then
      -- file couldn't be opened
      if ui_message_box_yes_no("Open", "Unable to open "&file_name&"\n\n"&
                     "Do you want to create it?") = 0 then
	  return 0
      end if
    else
      -- read the contents of the file into text
      s = gets(fn)
      while sequence(s) do
	  text &= s
	  s = gets(fn)
      end while
      close(fn)
    end if

    if not tab then
      new_tab(file_name)
      tab = current_tab
    end if
    update_tab_timestamp()

    result = ssm(SCI_CLEARALL)
    result = ssm(SCI_SETTEXT, 0, text)
    result = ssm(SCI_SETSAVEPOINT)
    modified = 0
    if tab then
      update_tab_name()
    end if
    
    result = ssm(SCI_SETSEL)
    result = ssm(SCI_EMPTYUNDOBUFFER)

    add_recent_file(file_name)
    return tab
end function

procedure save_file()
    atom fn, junk

    ssm(SCI_SETSAVEPOINT, 0, 0)
    modified = 0

    fn = open(file_name, "wb")
    puts(fn, get_edit_text())
    close(fn)

    update_tab_name()
    update_tab_timestamp()
end procedure

global function save_file_as()  -- returns 1 if ok, 0 if cancelled
    object temp

    temp = ui_get_save_file_name(file_name)
    if length(temp) = 0 then return 0 end if

    file_name = canonical_path(temp, 0, CORRECT)
    tab_file_names[current_tab] = file_name
    save_file()
    update_tab_name()
    return 1
end function


global function save_if_modified(integer confirm)  -- returns 1 if ok, 0 if cancelled
    atom result, junk
    sequence text
    
    if not get_modified() and length(file_name) != 0 then
       return 1
    end if

    if confirm then
	text = ""
	if length(file_name) then
	    text = " in " & file_name
	end if
	text = "The text"&text&" has changed.\n\nDo you want to save the changes?"
	result = ui_message_box_yes_no_cancel(window_title, text)
	if result != 1 then -- no or cancel
	    return result + 1
	end if
    end if

    if length(file_name) = 0 then
        return save_file_as()
    end if
    save_file()
    return 1
end function

global function save_modified_tabs()  --returns 1 if ok, 0 if cancelled
    integer idx
    atom saved_hedit
    saved_hedit = hedit
    for tab = 1 to length(tab_hedits) do
        hedit = tab_hedits[tab]
        idx = find(tab_file_names[tab], recent_files)
        if idx then
            recent_pos[idx] = get_pos()
        end if
        if get_modified() then
            select_tab(tab)
            if save_if_modified(1) = 0 then
                return 0 -- cancelled
            end if
            saved_hedit = hedit
        end if
    end for
    hedit = saved_hedit
    return 1
end function

global function get_tab_arguments()
    return tab_arguments[current_tab]
end function

global procedure set_tab_arguments(sequence s)
    tab_arguments[current_tab] = s
end procedure

global procedure close_tab()
    integer tab
    tab = current_tab
    save_recent_pos()
    ui_close_tab(tab)

    tab_hedits = tab_hedits[1..tab-1] & tab_hedits[tab+1..$]
    tab_file_names = tab_file_names[1..tab-1] & tab_file_names[tab+1..$]
    tab_timestamps = tab_timestamps[1..tab-1] & tab_timestamps[tab+1..$]
    tab_arguments = tab_arguments[1..tab-1] & tab_arguments[tab+1..$]
    current_tab = 0
    if length(tab_hedits) = 0 then
	new_file() -- must always have a edit available
    elsif tab > length(tab_hedits) then
	tab = length(tab_hedits)
    end if
    select_tab(tab)
end procedure

global procedure new_file()
    atom junk

    new_tab("")
    ssm(SCI_SETTEXT, 0, "")
    ssm(SCI_SETSAVEPOINT, 0, 0)
end procedure


global procedure check_externally_modified_tabs()
    atom ts
    for i = 1 to length(tab_file_names) do
        if length(tab_file_names[i]) and tab_timestamps[i] != -1 then
            ts = get_timestamp(tab_file_names[i])
            if ts != tab_timestamps[i] then
	          --? {ts, tab_timestamps[i]}
                 -- clear the timestamp here so that don't repeat when the MessageBox retriggers WM_SETFOCUS
		tab_timestamps[i] = -1
                if ui_message_box_yes_no(window_title, tab_file_names[i] & 
                                         "\n\nThis file has been modified by another application.  Do you want to reload it?") then
                    select_tab(i)
                    open_file(tab_file_names[i], 1)
                else
                    tab_timestamps[i] = ts
                end if
            end if
        end if
    end for
end procedure


global procedure add_recent_file(sequence filename)
    integer idx
    idx = find(filename, recent_files)
    if idx then
        -- move it to the top of the list
        recent_files = {recent_files[idx]} & recent_files[1..idx-1] & 
                       recent_files[idx+1..length(recent_files)]
        recent_pos = {recent_pos[idx]} & recent_pos[1..idx-1] &
                      recent_pos[idx+1..length(recent_pos)]   
    else
        idx = length(recent_files)
        if idx >= max_recent_files then
            idx -= 1
        end if
        recent_files = {filename} & recent_files[1..idx]
        recent_pos = {0} & recent_pos[1..idx]
    end if
    ui_refresh_file_menu(recent_files)
end procedure

global procedure save_recent_pos()
    integer idx
    idx = find(file_name, recent_files)
    if idx then
        recent_pos[idx] = get_pos()
    end if
end procedure

global procedure open_recent(integer idx)
    atom junk
    integer tab
    if idx >= 1 and idx <= length(recent_files) then
        tab = open_file(recent_files[idx], 0)
        if tab then
            ssm(SCI_SETSEL, recent_pos[1], recent_pos[1])
            set_top_line(-1) -- set the top visible line to the current line
        end if
    end if
end procedure


--------------------------------------
-- help routines
--------------------------------------

sequence help_dir

global procedure show_help(sequence file, sequence anchor)
    integer ok = 0
    integer f = open(help_dir & file & ".html", "r")
    sequence html = ""
    if f = -1 then
        return
    end if
    object line = gets(f)
    while sequence(line) do
	if match("<a name=", line) = 1 then
	    sequence a = ""
	    for i = 10 to length(line) do
	        if line[i] = '"' then
	            a = line[10..i-1]
	            exit
	        end if
	    end for
	    --puts(1, a&"\n")
	    if equal(a, anchor) then
	        ok = 1
	    elsif ok = 1 and (
		match("_comments", a) or
		match("_example", a) or
		match("_returns", a) or
		match("_parameters", a) or
		match("_platform", a) or
		match("_seealso", a)
	    ) then
		ok = 1
	    else
		ok = 0
	    end if
	end if
	if ok then
	    html &= line
	end if
        line = gets(f)
    end while
    close(f)
    ui_show_help(html)
end procedure

function tr(sequence s, sequence src, sequence dst)
    for i = 1 to length(s) do
        integer x = find(s[i], src)
        if x then
            s[i] = dst[x]
        end if
    end for
    return s
end function

global procedure context_help()
    sequence text, decls, word, name_space, path
    integer pos, junk
    object help

    text = get_edit_text()
    pos = get_pos()
    word = word_pos(text, pos)
    if length(word) < 2 then return end if
    name_space = word[2]
    word = word[1]

    -- load the search.dat file
    if length(search_dat) = 0 then
        sequence paths = include_paths(0)
        for i = 1 to length(paths) do
	    path = paths[i]
	    if path[$] = SLASH then
	        path = path[1..$-1]
	    end if
	    path &= join_path({"..","docs","html"}) & SLASH
	    --puts(1, path&"\n")
	    integer f = open(path & "js" & SLASH & "search.js","r")
	    if f != -1 then
	        help_dir = canonical_path(path)
	        if help_dir[$] != SLASH then
	            help_dir &= SLASH
	        end if
	        object line = gets(f)
	        while sequence(line) do
	            integer x = find(':', line)
	            if x and line[1] = '"' then
			--puts(1, line[2..x-2]&" "&line[x+1..$]&"\n")
	                search_idx = append(search_idx, line[2..x-2])
	                line = tr(line[x+1..$-1], "[]", "{}")
	                line = value(line)
	                search_dat = append(search_dat, line[2])
	            end if
	            line = gets(f)
	        end while
	        close(f)
	        exit
	    end if
        end for
	if length(search_dat) = 0 then
	    ui_message_box_error(window_title, "File not found: euphoria/docs/html/js/search.js")
	    return
	end if
    end if
    
    -- search search.dat for matching entry
    help = {}
    for i = 1 to length(search_idx) do
        if equal(search_idx[i], word) then
            help = search_dat[i]
            exit
        end if
    end for
    if atom(help) or length(help) = 0 then
	return
    end if

    if length(help) > 1 then
	-- multiple help entries
	path = ""
	decls = get_declarations(parse(text, file_name), pos, name_space)
	for j = 1 to length(decls) by 2 do
	  if equal(decls[j], word) then
	    if atom(decls[j+1]) then
	      path = file_name
	    else
	      path = decls[j+1][1]
	    end if
	    
	    for i = 1 to length(help) do
		if match(sreplace(help[i][1],"_",{SLASH})&".e", path) then
		    --show_help(help[i][1], help[i][2])
		    ui_show_uri("file://" & help_dir & help[i][1] & ".html#" & help[i][2])
		    return
		end if
	    end for
	  end if
	end for
    end if

    -- only one help entry, just show it
    --show_help(help[1][1], help[1][2])
    ui_show_uri("file://" & help_dir & help[1][1] & ".html#" & help[1][2])
end procedure

global procedure open_tutorial()
    new_file()
    ssm(SCI_SETTEXT, 0, `
----------------------------------------
-- Welcome to the Wee Euphoria Editor --
----------------------------------------

-- Scintilla Keys:
--
-- Text Size
--   Magnify                         Control keypad +
--   Reduce                          Control keypad -
--   Normal                          Control keypad /
--
-- Cursor Movement
--   Go to start of document         Control Home
--   Go to end of document           Control End
--   Go to start of line             Control Home
--   Go to end of line               Control End
--   Go to previous paragraph        Control Up
--   Go to next paragraph            Control Down
--   Go to previous word             Control Left
--   Go to next word                 Control Right
--   (shift extends selection)
--
-- Delete Text
--    To start of line               Control Shift Backspace
--    To start of word               Control Backspace
--    To end of word                 Control Delete
--
-- Indent
--    Indent block                Tab
--    Unindent block              Shift Tab


-- Wee offers autocompletion for the following keywords.
-- Type a space at the end of each keyword below to see the 
-- expansion.  After the expansion, press Enter to jump over 
-- the "then" or "do" to the next line.

if

-------------------------
while

-------------------------
switch

-------------------------
procedure

-------------------------
function

-------------------------
type

-------------------------
for

-- The "for" keyword also inserts " =  to " but is overtypable,
-- meaning you can continue typing " = " and it will replace the
-- existing characters.  Or you can move your cursor using the 
-- arrow keys.

-- Likewise, pair characters are inserted for typing the following
-- characters: ( [ { " '
-- And you can overtype the closing character if you wish.
-- Pressing "(" results in "()"
-- Typing "123" results in "(123)"
-- Pressing ")" results in "(123)"
-- Try it!

-- If the initial character is deleted using backspace, the
-- inserted pair will also be removed.
-- Pressing "(" results in "()"
-- Pressing backspace results in ""


-- Wee also knows about subroutines you've defined.
-- Press F2 to see a list.  If you've filled in names for the 
-- subroutine declarations above, they should appear.
-- Pressing OK or Enter will move the cursor to the subroutine
-- definition.  If your cursor is on the name of an existing
-- subroutine, it will be the highlighted entry.
-- Try it!  Type the name of a subroutine and hit F2.


-- Autocompletion for any type of identifier is done with
-- Control+Space.  The standard library is also searched for 
-- completions, indicated by "--include" in the list entry, and
-- when selected, the include statement will be inserted 
-- automatically near the top of the file.


-- Typing ':' after a namespace identifier will show an auto-
-- complete list for definitions within a specific namespace.


-- Pressing Ctrl+F2 while on an identifier will move the cursor
-- to the definition of that identifier.


-- Pressing Shift+F2 while on a subroutine identifier will display
-- a calltips popup.  The popup shows the types and names of the 
-- arguments to the subroutine, with default arguments enclosed in
-- square brackets.


-- Typing '(' after a subroutine identifier will show the calltips
-- popup, and highlight the argument position as you type.


-- Pressing F4 will open a dialog showing the most recent ex.err
-- file, with the error message and a list of either:
--  the call stack of the subroutines at the point of the crash,
--  or a list of undefined symbols.
-- Select an item in the list and press Goto Error to move the 
-- cursor to that location.


-- That's all, have fun!
`)
end procedure



-------------------------------------------------------------------
-- ex.err file handling routines
-------------------------------------------------------------------

-- returns {"filename:line", "message", "line1", "line2", "line3"...}
global function get_ex_err()
    integer fn
    object line, msg, txt
    sequence result, tmp
    
    fn = open(ex_err_name, "r")
    if fn = -1 then
	return {}
    end if
    result = {}
    line = gets(fn) -- filename:line
    if not atom(line) then
        msg = gets(fn)
        result = {line, msg}
        if match("Errors resolving the following references", msg) then
	    txt = gets(fn)
	    while sequence(txt) and length(txt) > 1 do
		result = append(result, txt)
	        txt = gets(fn)
	    end while
        else
	    result = append(result, line)
	    tmp = "... called from "
	    txt = gets(fn)
	    while sequence(txt) and length(result) < 100 do
		if length(txt) > length(tmp) and equal(txt[1..length(tmp)], tmp) then
		    result = append(result, txt[length(tmp)+1..$])
		end if
	        txt = gets(fn)
	    end while
        end if
    end if
    close(fn)
    return result
end function

-- get the text between two delimeters, searching from end of text
function text_between(sequence text, integer delim1, integer delim2)
    for i = length(text) to 1 by -1 do
	if text[i] = delim2 then
	    for j = i-1 to 1 by -1 do
		if text[j] = delim1 then
		    return text[j+1..i-1]
		end if
	    end for
	    exit
	end if
    end for
    return ""
end function

global procedure goto_error(sequence err, integer idx)
    integer a, b, c, line, tab, col
    sequence val, file, item, text
    
    if idx < 0 or idx > length(err)-2 then
        return
    end if
    
    text = err[idx+2]
    
    a = find('(', text)
    b = find(')', text)
    c = 0
    for i = length(text) to 1 by -1 do
        if text[i] = ':' then
            c = i
            exit
        end if
    end for
    item = ""
    if a < c and c < b then
	-- 'blah' (filename:line) has not been declared
	file = dirname(ex_err_name) & SLASH & text[a+1..c-1]
        val = value(text[c+1..b-1])
        item = text_between(text, '\'', '\'')
    elsif c then
	-- c:\path\to\filename.ext:line subroutine_name()
        file = text[1..c-1]
        val = value(text[c+1..$])
        item = text_between(err[2], '\'', '\'')
    else
	return
    end if
    tab = open_file(file, 0)
    if tab and val[1] = GET_SUCCESS then
        line = val[2]-1
	col = 0
        if length(item) then
	    col = match(item, get_line(line))
	    if col then 
		col -= 1
	    else
		item = ""
	    end if
	end if
	col += ssm(SCI_POSITIONFROMLINE, line)
        ssm(SCI_SETSEL, col, col + length(item))
        set_top_line(line)
    end if
end procedure

global procedure view_error()
    atom fn, result
    object s
    integer line, colon, caret, tab
    sequence file, message
    
    ui_view_error()
    return
    
    fn = open("ex.err", "r")
    if fn = -1 then
	return
    end if
    s = gets(fn)  -- "filename:line"
    if atom(s) then
        close(fn)
	return
    end if
    if length(s) < 3 then
        close(fn)
	return
    end if
    colon = match(":", s[3..length(s)]) + 2
    if colon < 3 then
        close(fn)
	return
    end if
    file = s[1..colon-1]
    tab = find(file, tab_file_names)
    if tab then
      select_tab(tab)
    else
	if ui_message_box_yes_no("Goto Error",
		"The file ex.err refers to\n"&file&
		"\n\nDo you want to open this file?")= 0 then
            close(fn)
	    return
	end if
	tab = open_file(file, 0)
    end if
    s = value(s[colon+1..length(s)])
    if s[1] != GET_SUCCESS 
    or not integer(s[2]) then
        close(fn)
	return
    end if
    line = s[2]
    s = gets(fn)
    if atom(s) then
        close(fn)
	return
    end if
    message = s
    s = gets(fn)
    s = gets(fn)
    close(fn)
    if atom(s) then
	return
    end if
    caret = find('^', s)
    caret += ssm(SCI_POSITIONFROMLINE, line-1)
    result = ssm(SCI_SETSEL, caret, caret)
    set_top_line(-1)
    result = ui_message_box_error("Goto Error", message)
end procedure

global procedure reset_ex_err()
    if length(run_file_name) = 0 then
        return
    end if
    ex_err_name = dirname(run_file_name) & SLASH & "ex.err"
    ex_err_timestamp = get_timestamp(ex_err_name)
end procedure

global procedure check_ex_err()
  atom ts

  if length(run_file_name) = 0 then return end if

  ts = get_timestamp(ex_err_name)
--printf(1, "%s %d %d\n", {ex_err_name, ts, ex_err_timestamp})
  if ts > ex_err_timestamp then
    run_file_name = ""
    ui_view_error()
  end if
  ex_err_timestamp = ts
end procedure


-------------------------------------------------------------------
-- code syntax routines
-------------------------------------------------------------------

global procedure view_declaration()
    sequence text, decls, word, name_space
    integer pos
    
    text = get_edit_text()
    pos = get_pos()
    word = word_pos(text, pos)
    if length(word) < 2 then return end if
    name_space = word[2]
    word = word[1]

    decls = get_declarations(parse(text, file_name), pos, name_space)
    for i = 1 to length(decls) by 2 do
      if equal(decls[i], word) then
        goto_pos(decls[i+1], length(word))
        exit
      end if
    end for
end procedure


global procedure view_completions()
    sequence text, word, decls, name_space, suggestions
    integer pos, junk, style

    pos = get_pos()

    style = ssm(SCI_GETSTYLEAT, pos-2)
    if style = SCE_LUA_STRING or style = SCE_LUA_COMMENTLINE then
        return -- no completion in strings or comments
    end if

    -- use scintilla's code completion
    text = get_edit_text()
    word = word_pos(text, pos)
    if length(word) < 4 then 
	return
    end if
    --printf(1, "word=%s namespace=%s pos=%d end=%d\n", word)
    ssm(SCI_SETSEL, word[4], word[4])
    name_space = word[2]
    word = word[1]

    decls = get_declarations(parse(text, file_name), pos, name_space)
    if length(decls) = 0 or length(name_space) = 0 then
	suggestions = suggest_includes(word, name_space)

	-- filter duplicate suggestions
	for i = 1 to length(suggestions) by 2 do
	    if not find(suggestions[i+1], decls) then
		decls &= suggestions[i..i+1]
	    end if
	end for
    end if
    
    if length(decls) = 0 then
	return
    end if
    text = ""
    for i = 1 to length(decls) by 2 do
	if length(decls[i]) >= length(word) and equal(decls[i][1..length(word)], word) then
	  if length(text) then 
	    text &= '\n'
	  end if
	  text &= decls[i]
	end if
    end for
    if length(text) then
      ssm(SCI_AUTOCSHOW, length(word), text)
    end if
end procedure

-- show the subroutine arguments, usually triggered after a pressing '('
global procedure view_subroutine_arguments()
    sequence text, word, decls, name_space
    integer pos, end_pos, junk, calltip_save, style

    pos = get_pos()
    style = ssm(SCI_GETSTYLEAT, pos-2)
    if style = SCE_LUA_STRING or style = SCE_LUA_COMMENTLINE then
        return -- no completion in strings or comments
    end if

    calltip_save = calltip_pos
    if ssm(SCI_GETCHARAT, pos-1) = '(' then
        calltip_pos = pos
        pos -= 1
    end if

    -- use scintilla's code completion
    text = get_edit_text()
    word = word_pos(text, pos)
    if length(word) < 4 then
        calltip_pos = calltip_save
        return
    end if
    pos = word[3]
    end_pos = word[4]
    name_space = word[2]
    word = word[1]

    decls = get_subroutine_arguments(parse(text, file_name), word, name_space)
    if length(decls) then
        decls = decls[$] -- overloaded?  use the last one
        if calltip_save != -1 then
	    calltip_stack &= {calltip_save, calltip_args, calltip_text}
	    --? calltip_stack
        end if
        text = decls[1] & " " & decls[2] & "("
	calltip_args = {}
        for i = 3 to length(decls) by 3 do
          if i != 3 then text &= ", " end if
          if decls[i+2] then text &= "[" end if
          calltip_args &= {{length(text), 0}}
          text &= decls[i] & " " & decls[i+1]
          calltip_args[$][2] = length(text)
          if decls[i+2] then text &= "]" end if
        end for
        text &= ")"
        --puts(1, text & "\n")
        calltip_text = text
        ssm(SCI_CALLTIPSHOW, pos, text)
        if length(calltip_args) then
            ssm(SCI_CALLTIPSETHLT, calltip_args[1][1], calltip_args[1][2])
        else
	    calltip_pos = -1 -- no arguments, no need to update
        end if
        return
    end if
    
    -- decl not found, search includes instead
    decls = suggest_includes(word, name_space)
    text = ""
    for i = 1 to length(decls) by 2 do
	if length(decls[i]) >= length(word) and equal(decls[i][1..length(word)], word) then
	  if length(text) then
	    text &= '\n'
	  end if
	  text &= sreplace(decls[i], " --", "( --")
	end if
    end for
    if length(text) then
      ssm(SCI_GOTOPOS, end_pos+1)
      ssm(SCI_AUTOCSHOW, length(word)+1, text)
    end if
end procedure


procedure update_subroutine_arguments()
    sequence text
    integer pos, arg, ch
    
    pos = get_pos()-1
 
    ch = ssm(SCI_GETCHARAT, pos, 0)
    if ch != ',' and ch != ')' and ssm(SCI_GETCHARAT, pos+1, 0) != ',' then
        return
    end if
    --? {calltip_pos, pos}
    while calltip_pos != -1 or length(calltip_stack) != 0 do
    
	if calltip_pos = -1 or pos < calltip_pos then
	    calltip_pos = calltip_stack[$-2]
	    calltip_args = calltip_stack[$-1]
	    calltip_text = calltip_stack[$]
	    ssm(SCI_CALLTIPSHOW, calltip_pos, calltip_text)        
	    calltip_stack = calltip_stack[1..$-3]
	end if
	
	-- get the text from after '(' up to the cursor
	text = repeat(0, pos - calltip_pos + 1)
	for i = 1 to length(text) do
	    text[i] = ssm(SCI_GETCHARAT, calltip_pos+i-1)
	end for
	--puts(1, text&"\n")
	
	arg = parse_argument_position(text)
	if arg = 0 then
	    ssm(SCI_CALLTIPCANCEL)
	    calltip_pos = -1
	elsif arg > length(calltip_args) then
	    ssm(SCI_CALLTIPSETHLT, 0, 0)
	    exit
	else
	    ssm(SCI_CALLTIPSETHLT, calltip_args[arg][1], calltip_args[arg][2])
	    exit
	end if
    end while
end procedure


function ltrim(sequence s)
  for i = 1 to length(s) do
    if not find(s[i], " \t\n\r") then
      return s[i..$]
    end if
  end for
  return "" 
end function


function rtrim(sequence s)
  for i = length(s) to 1 by -1 do
    if not find(s[i], " \t\n\r") then
      return s[1..i]
    end if
  end for
  return "" 
end function


-- expand "if " to "if  then\n\nend if", etc.
procedure auto_expand()
    sequence text, indent
    integer pos, end_pos
    atom junk

    -- make sure the current position is at the end of the line
    pos = get_pos()
    end_pos = get_line_end_position(-1)
    if pos != end_pos then return end if

    -- save the indentation and trim the line
    indent = get_line(-1)
    text = ltrim(indent)
    indent = "\n" & indent[1..$-length(text)]
    text = rtrim(text)

    -- get the text to insert
    if equal(text, "if") then
        text = {" then", "end if"}
    elsif equal(text, "elsif") or equal(text, "case") then
        text = {" then"}
    elsif equal(text, "while") then
        text = {" do", "end while"}
    elsif equal(text, "loop") then
        text = {"do", "end loop"}
    elsif equal(text, "for") then
        text = {" =  to  do", "end for"}
        --text = {" do", "end for"}
        insert_chars &= " ot  = "
    elsif equal(text, "switch") then
        text = {" do", "end switch"}
        
    else
        if match("global ", text) = 1
        or match("public ", text) = 1
        or match("export ", text) = 1 then
            text = ltrim(text[7..$])
        end if
	if equal(text, "procedure") then
            text = {"()", "end procedure"}
        elsif equal(text, "function") then
            text = {"()", "end function"}
        elsif equal(text, "type") then
            text = {"()", "end type"}
        else
            return
        end if
        insert_chars &= ")("
    end if
    if length(text) = 1 then
        text = text[1] & indent & indent_str
    else
        text = text[1] & indent & indent_str & indent & text[2]
    end if
    
    -- save the line for auto_indent()
    expand_line = ssm(SCI_LINEFROMPOSITION, pos)

    -- insert the text and restore cursor position
    ssm(SCI_INSERTTEXT, pos, text)
end procedure


procedure auto_indent()
    integer line, pos, end_pos
    sequence indent
    atom junk

    -- get the previous line and get the indentation
    pos = get_pos()
    line = ssm(SCI_LINEFROMPOSITION, pos) - 1
    end_pos = get_line_end_position(line)

    if line = expand_line then
        -- delete the newline character and go to end of the next line
	ssm(SCI_DELETERANGE, end_pos, pos - end_pos)
	end_pos = get_line_end_position(line + 1)
	ssm(SCI_GOTOPOS, end_pos)
        expand_line = -1
        return
    end if
    expand_line = -1
    
    -- get the indentation of the previous line, and remove newline
    indent = get_line(line)
    for i = length(indent)-length(ltrim(indent)) to 0 by -1 do
      if i = 0 or (indent[i] != '\n' and indent[i] != '\r') then
        indent = indent[1..i]
        exit
      end if
    end for

    -- insert the indentation
    ssm(SCI_ADDTEXT, length(indent), indent)
end procedure


procedure do_brace_highlight(atom hedit)
  integer pos, brace, ch
  brace = -1
  pos = get_pos()-1
  if find(ssm(SCI_GETCHARAT, pos, 0), "{}()[]") then
    brace = ssm(SCI_BRACEMATCH, pos, 0)
  end if
  if brace = -1 then
    pos += 1
    if find(ssm(SCI_GETCHARAT, pos, 0), "{}()[]") then
      brace = ssm(SCI_BRACEMATCH, pos, 0)
    end if
    if brace = -1 then
      pos = -1
    end if
  end if
  brace = ssm(SCI_BRACEHIGHLIGHT, pos, brace)
end procedure
-- FIXME: this has a problem with brace chars within strings, for ex: {1, "}{", 2}


procedure auto_complete_selection(integer pos, sequence text)
    integer inc, len, insert_line, arg
    sequence line
    
    -- insert include statement if completion contains it
    inc = match(" --include", text)
    if inc then
        ssm(SCI_AUTOCCANCEL, 0, 0)

	len = get_pos() - pos

        arg = text[inc-1] = '('
        if arg then
	    -- delete the existing '(' since we are adding another one
	    len -= 1
            ssm(SCI_DELETERANGE, pos + len, 1)
        end if
        
	if len+1 <= inc then
	    ssm(SCI_ADDTEXT, inc-1-len, text[len+1..inc])
        end if
        text = text[inc+3..$] & "\n"

	-- search first few lines for include statements
	insert_line = -1
	for i = 0 to 100 do
	    line = ltrim(get_line(i))
	    --printf(1, "%d %d %s\n", insert_line
	    if length(line) >= 8 and equal(line[1..8], "include ") then
	        insert_line = i+1
	    elsif insert_line != -1 then
	        exit
	    end if
	end for
	if insert_line = -1 then
	    -- insert after consecutive comment lines
	    insert_line = 0
	    for i = 0 to 100 do
		line = ltrim(get_line(i))
	        if length(line) >= 2 and line[1]='-' and line[2]='-' then
		    insert_line = i+1
		else
		    exit
		end if
	    end for
	end if
	inc = ssm(SCI_POSITIONFROMLINE, insert_line, 0)
	if inc = -1 or inc > pos then
	    inc = 0
	end if
	ssm(SCI_INSERTTEXT, inc, text)
	if arg then
	    view_subroutine_arguments()
	end if
    end if
end procedure

-- insert closing character when user types ( [ { ' "
procedure insert_pair()
    integer pos, style, ch

    pos = get_pos()-1

    -- avoid inside strings and comments
    if pos != get_line_start_position(-1) then
	style = ssm(SCI_GETSTYLEAT, pos-1)
	if style = SCE_LUA_COMMENTLINE or 
	  (style = SCE_LUA_STRING and 
	   style = ssm(SCI_GETSTYLEAT, pos+1)) then
	    return
	end if
    end if

    -- avoid inside words or numbers
    for i = pos+1 to get_line_end_position(-1) do
	ch = ssm(SCI_GETCHARAT, i)
	style = ssm(SCI_GETSTYLEAT, i)
	--? {ch, style}
	if find(ch, ",)}]\r\n+-*/=!<>#&\0") or style = SCE_LUA_WORD then
	    exit
	elsif ch != ' ' and ch != '\t' then
	    return
	end if
    end for
    ch = ssm(SCI_GETCHARAT, pos, 0)
    if ch = '(' then
	ch = ')'
    elsif ch = '{' then
	ch = '}'
    elsif ch = '[' then
	ch = ']'
    end if
    ssm(SCI_INSERTTEXT, pos+1, {ch})
    insert_chars &= ch
end procedure

-- remove the characters inserted by insert_pair(), won't work for ' " tho
procedure delete_pair()
    if length(insert_chars) = 0 then
	return
    end if
    if insert_chars[$] = last_deleted_char then
	insert_chars = insert_chars[1..$-1]
    elsif (last_deleted_char = '(' and insert_chars[$] = ')') or
          (last_deleted_char = '[' and insert_chars[$] = ']') or
          (last_deleted_char = '{' and insert_chars[$] = '}') then
	ssm(SCI_DELETERANGE, get_pos(), 1)
	insert_chars = insert_chars[1..$-1]
    end if
end procedure

-- open file(s) from a drag and drop operation
procedure open_uri(sequence uri)
    uri = split(uri, "\r\n")
    for i = 1 to length(uri) do
	? uri[i]
        if match("file://", uri[i]) = 1 then
            open_file(uri[i][8..$], 0)
        end if
    end for
end procedure

procedure log_notification(atom notification)
  integer code, pos, ch, modifiers
  --? peek4u({notification, 24})
  code = peek4u(notification+8)
  pos = peek4u(notification+12)
  if code = SCN_STYLENEEDED then
    puts(1, "SCN_STYLENEEDED\n")
  elsif code = SCN_CHARADDED then
    ch = peek4s(notification+16)
    printf(1, "SCN_CHARADDED ch=%d '%s'\n", {ch, {ch}})
  elsif code = SCN_SAVEPOINTREACHED then
    puts(1, "SCN_SAVEPOINTREACHED\n")
  elsif code = SCN_SAVEPOINTLEFT then
    puts(1, "SCN_SAVEPOINTLEFT\n")
  elsif code = SCN_MODIFYATTEMPTRO then
    puts(1, "SCN_MODIFYATTEMPTRO\n")
  elsif code = SCN_KEY then
    ch = peek4s(notification+16)
    modifiers = peek4s(notification+20)
    printf(1, "SCN_KEY ch=%d modifiers=#%x\n", {ch, modifiers})
  elsif code = SCN_DOUBLECLICK then
    puts(1, "SCN_DOUBLECLICK\n")
  elsif code = SCN_UPDATEUI then
    printf(1, "SCN_UPDATEUI updated=#%x\n", {peek4s(notification+88)})
  elsif code = SCN_MODIFIED then
    puts(1, "SCN_MODIFIED\n")
  elsif code = SCN_MACRORECORD then
    puts(1, "SCN_MACRORECORD\n")
  elsif code = SCN_MARGINCLICK then
    puts(1, "SCN_MARGINCLICK\n")
  elsif code = SCN_NEEDSHOWN then
    puts(1, "SCN_NEEDSHOWN\n")
  elsif code = SCN_PAINTED then
    --gets sent after each caret blink
    --puts(1, "SCN_PAINTED\n")
  elsif code = SCN_USERLISTSELECTION then
    puts(1, "SCN_USERLISTSELECTION\n")
  elsif code = SCN_URIDROPPED then
    puts(1, "SCN_URIDROPPED\n")
  elsif code = SCN_DWELLSTART then
    puts(1, "SCN_DWELLSTART\n")
  elsif code = SCN_DWELLEND then
    puts(1, "SCN_DWELLEND\n")
  elsif code = SCN_ZOOM then
    puts(1, "SCN_ZOOM\n")
  elsif code = SCN_HOTSPOTCLICK then
    puts(1, "SCN_HOTSPOTCLICK\n")
  elsif code = SCN_HOTSPOTDOUBLECLICK then
    puts(1, "SCN_HOTSPOTDOUBLECLICK\n")
  elsif code = SCN_HOTSPOTRELEASECLICK then
    puts(1, "SCN_HOTSPOTRELEASECLICK\n")
  elsif code = SCN_INDICATORCLICK then
    puts(1, "SCN_INDICATORCLICK\n")
  elsif code = SCN_INDICATORRELEASE then
    puts(1, "SCN_INDICATORRELEASE\n")
  elsif code = SCN_CALLTIPCLICK then
    puts(1, "SCN_CALLTIPCLICK\n")
  elsif code = SCN_AUTOCSELECTION then
    puts(1, "SCN_AUTOCSELECTION\n")
  elsif code = SCN_AUTOCCANCELLED then
    puts(1, "SCN_AUTOCCANCELLED\n")
  elsif code = SCN_AUTOCCHARDELETED then
    puts(1, "SCN_AUTOCCHARDELETED\n")
  elsif code = SCN_FOCUSIN then
    puts(1, "SCN_FOCUSIN\n")
  elsif code = SCN_FOCUSOUT then
    puts(1, "SCN_FOCUSOUT\n")
  end if
end procedure


ifdef BITS64 then
constant
  NOTIFICATION_CODE = 16,
  NOTIFICATION_POS = 24,
  NOTIFICATION_CH = 28,
  NOTIFICATION_MODIFIERS = 32,
  NOTIFICATION_MODIFICATIONTYPE = 36,
  NOTIFICATION_TEXT = 40,
  NOTIFICATION_LENGTH = 48,
  NOTIFICATION_UPDATED = 116
elsedef
constant
  NOTIFICATION_CODE = 8,
  NOTIFICATION_POS = 12,
  NOTIFICATION_CH = 16,
  NOTIFICATION_MODIFIERS = 20,
  NOTIFICATION_MODIFICATIONTYPE = 24,
  NOTIFICATION_TEXT = 28,
  NOTIFICATION_LENGTH = 32,
  NOTIFICATION_UPDATED = 88
end ifdef


global function sci_notify(atom hedit, atom data, atom notification, atom userdata)
  integer code, pos, ch, modifiers, updated, len
  atom ptr
  
  --? {ctl, data, notification, userdata}
  if notification = 0 then return 0 end if
  --log_notification(notification)
  code = peek4u(notification+NOTIFICATION_CODE)
  if code = SCN_UPDATEUI then
    updated = peek4u(notification+NOTIFICATION_UPDATED)
    --? {updated, insert_chars, last_deleted_char}
    if and_bits(updated, SC_UPDATE_SELECTION+SC_UPDATE_CONTENT) = SC_UPDATE_SELECTION then
	-- selection moved and content was not changed
	--? {updated, insert_chars}
	insert_chars = ""
    elsif last_deleted_char then
	delete_pair()
        last_deleted_char = 0
    end if
    if ssm(SCI_CALLTIPACTIVE) then
        update_subroutine_arguments()
    end if
    update_status()
    do_brace_highlight(hedit)

  elsif code = SCN_SAVEPOINTREACHED or code = SCN_SAVEPOINTLEFT then
    modified = (code = SCN_SAVEPOINTLEFT)
    update_tab_name()

  elsif code = SCN_KEY then
    ch = peek4s(notification+NOTIFICATION_CH)
    modifiers = peek4s(notification+NOTIFICATION_MODIFIERS)
    -- on OSX, META and SHIFT are the only modifiers we receive
    
    if ch = 'Z' and and_bits(modifiers, SCMOD_CTRL+SCMOD_META) then
      if and_bits(modifiers, SCMOD_SHIFT) then
        ssm(SCI_REDO, 0, 0)
      else
        ssm(SCI_UNDO, 0, 0)
      end if

    elsif ch >= '1' and ch <= '9' and and_bits(modifiers, SCMOD_ALT+SCMOD_META) then
      select_tab(ch - '0')

    elsif ch < 128 then
      --printf(1, "SCN_KEY ch=%d '%s' modifiers=%d\n", {ch, {ch}, modifiers})
    else
      --printf(1, "SCN_KEY ch=#%x modifiers=%d\n", {ch, modifiers})
    end if

  elsif code = SCN_CHARADDED then
    ch = peek4s(notification+NOTIFICATION_CH)
    --printf(1, "SCN_CHARADDED ch=%d '%s'\n", {ch, {ch}})

    if length(insert_chars) and ch = insert_chars[$] then
	-- the user retyped the insert character, so delete it
        ssm(SCI_DELETERANGE, get_pos(), 1)
        -- the UPDATEUI will remove the insert_chars[$]
    elsif ch = ':' then
      view_completions()
    elsif ch = ' ' then
      auto_expand()
    elsif ch = '\n' then
      auto_indent()
    elsif ch = '(' then
      -- check for displaying subroutine arguments
      insert_pair()
      view_subroutine_arguments()
    elsif ch = '{' or ch = '[' then
      insert_pair()
    elsif ch = '"' or ch = '\'' then
      insert_pair()
    end if

  elsif code = SCN_AUTOCSELECTION then
    -- check for "--include" in selection, then add include statement near top of file
    --  or after the first non-commented line, or ideally with other includes
    ifdef BITS64 then
	ptr = peek8u(notification+NOTIFICATION_TEXT)
    elsedef
	ptr = peek4u(notification+NOTIFICATION_TEXT)
    end ifdef
    pos = peek4u(notification+NOTIFICATION_POS)
    auto_complete_selection(pos, peek_string(ptr))
    
  elsif code = SCN_MODIFIED then
    modifiers = peek4u(notification+NOTIFICATION_MODIFICATIONTYPE)
    if and_bits(modifiers, SC_MOD_BEFOREDELETE) then
	pos = peek4u(notification+NOTIFICATION_POS)
	len = peek4u(notification+NOTIFICATION_LENGTH)
	--? {modifiers, pos, len}
	if len = 1 then
	    last_deleted_char = ssm(SCI_GETCHARAT, pos)
	end if
    end if

  elsif code = SCN_URIDROPPED then
    ifdef BITS64 then
	ptr = peek8u(notification+NOTIFICATION_TEXT)
    elsedef
	ptr = peek4u(notification+NOTIFICATION_TEXT)
    end ifdef
    open_uri(peek_string(ptr))
    --puts(1, "SCN_URIDROPPED "& peek_string(ptr) &"\n")
    
  end if
  return 0
end function
